## 一、简单题

### 1.两数之和

```
1.两数之和，给出一个数组nums和一个target，在数组两面找两个数字之和为target的下标，作为数组返回。
	1.介绍一个数据结构，Map：
		Map对象里面存的是key: value的形式。
		通过map.set(key, value)设置里面的元素。
		通过map.has(key)判断里面是否存在这个key，存在返回true，不存在返回false。
		通过map.get(key)可以获取该元素的vaule
	2.通过一次遍历该数组，每一次先计算出nums[i] + X = target这个X，
		然后再去map里面看看有没有这个X，有呢就返回它的nums[i]和X的下标
		没有就把nums[i]存入map数据结构中，key为nums[i], value为下标i，
		那么等遍历完的时候就可以找出这两个数了
```

### 2.有效括号

```
方法：栈
第一步：
	定义栈，判断收个元素是否为([{的一个，是的话就push，不是就返回false；
第二步：
	字符串从第一个开始，stack永远拿最后一个进行比较，进行匹配：
		匹配成功：那么就将stack pop一下
		匹配失败：将stack.push(s[i])
第三步：
	判断最后的stack里面是否有元素
```

### 3.合并有序链表

```
方法一：普通思维
1.新建一个空链表，将空链表head记录，后面用于返回
2.while循环当两个都不为null时：
	l1.val < l2.val: 1): curr.next = l1(指向较小的) 2): l1 = l1.next(l1链表指针向后移动)
	l1.val >= l2.val 1): curr.next = l2(较小的是l2) 2): l2 = l2.next(l2指针向后移动)
	上面操作下来，curr链表添加了一个新元素，为了在新元素后面添加元素，那么就需要新链表指针移到最后，curr = curr.next;
3.while循环完成之后，要去判断l1,l2是否还有剩余元素
	l1===null: curr.next = l2;
	l2===null: curr.next = l1;
4.最后得到的curr新链表是 0->有序合并数组，所以应该返回 dummy.next;

方法2：递归
1.判断边界情况：
	如果两个有一个为null那么就直接返回对方
2.比较两个链表的值大小：
	l1.val < l2.val ：
```

### 3.链表是否有环

```
方法一：快慢指针 69% 23%
思路：通过快指针走两步，慢指针走一步，如果有环，那么快指针每次都会向前追上一步，在环中的某一点一定会相遇，等到slow==fast时，返回true，否则跳出while循环，说明条件fast.next && fast.next.next为null，则是线性链表，返回false
1.边界情况：head为空，说明没链表，则返回false。
2.定义快慢指针，指向头部。
3.while循环条件是fast.next 和fast.next.next不为null(一定要先fast.next，不然第二个next前面的fast.next.取不到会报错)
4.在里面执行的操作是，满指针走一步，快指针走两步：
	相遇(fast===slow)：返回true
	不相遇：说明是线性链表，则fast会先到达null，最终跳出循环，在循环外面返回false。
```



### 4.最大子序和

```
方法一：动态规划
1.建立一维数组，初始化dp[0]=nums[0],定义最大max=dp[0].
2.从1开始遍历nums，看看dp[i-1]是否大于0：
	dp[i-1]>0：dp[i]+=dp[i-1]
	dp[i-1]<0：dp[i]=nums[i]
	这样可以计算出以i个结尾的数组，他的最大子序和是多少
	在每一次循环时，都将max和dp[i]进行比较，得出最大值
3.最后返回比较出的max。
```

### 5.爬楼梯

```
方法一：动态规划 85% 98%
1.建立dp数组dp，初始化dp[0]=1;dp[1]=2;
2.状态转移方程为：dp[i]=dp[i-2]+dp[i-1];
3.返回结果 return dp[n-1];
```

### 6.对称二叉树

```
方法一：递归
1.首先定义一个检查左右子树是否相等的函数：
	边界情况：左右子树都为null，直接返回true
	递归机：如果两个子树都有，判断子树根节点的val是否相等，然后判断left.left===right.right，再判断left.right===right.left(因为	一个树需要比较根左右)，递归过程中有一个子树不存在，那么返回false。
2.调用递归：
	边界情况：根节点都没与的话，直接返回true了
	return(check(root.left,root.right))
```

### 7.二叉树最大深度

```js
方法一：递归
1.边界情况：首先没有根节点情况下，直接返回0即可
2.递归机
var maxDepth = function(root) {
 if(!root){
    return 0;
 }else {
     const left = maxDepth(root.left);
     const right = maxDepth(root.right);
     return Math.max(right, left) + 1;
 }
};
```

### 8.只出现一次的数

```
方法一：Map 45% 5% 待优化
1.遍历数组，对第一次遇见就加入map，第二次遇见就是用map.delete(key)删除这个key
2.最后可以确保map中只剩下出现一次的数：
	for(let res of map.keys()) return res;即可
```

