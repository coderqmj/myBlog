## 二、webpack配置文件

### 1.打包过程

**指定入口出口打包方式一：命令**

`webpack --ebtry ./src/main.js --output-path ./build`

**指定出口入口方式二：配置文件（重点）**

```js
// webpack.config.js
const path = require('path');
module.exports = {
  entry: './src/main.js',
  output: {
    filename: "boundle.js",
    // 必须是绝对路径
    path: path.resolve(__dirname, "./build")
  }
}
```

**假如文件名不是webpack.config.js**

- 那就没有办法打包成功了，怎么办？
- 因为执行`webpack`命令时，会去查找`webpack.config.js`这个文件执行 
- 解决：
  - 在配置文件里面修改build指令的配置参数

![](./images/webpack_01.png)

### 2.webpack依赖关系图

- webpack到底是如何对我们的项目进行打包的呢？
  - 事实上webpack处理应用程序时，根据命令或已配置的文件找到入口
  - 入口开始，生成一个 **依赖关系图**，这个依赖关系图会包含应用程序中所需的所有模块（js，css，图片，字体）
  - 遍历图结构，打包一个个模块（根据文件的不同使用不同的loader来解析）
- 上述的例子：
  - 例子一：安装了某个第三方库`axios`，但是并没有使用，所以打包不会带进去，打包后总体积不会增大。
  - 例子二：项目中创建的文件，没有被引用，最后打包不会在依赖图上，所以体积也不会增大。
  - 例子三：假如有个js文件里面有函数，js确实被引用了，但是函数未被执行，函数也不会被打包。
    - 涉及到tree shaking 

###  3.代码编写案例

- 写了个css，导入到文件，最后把它打包，最后会报错，原因是缺少加载css的loader

- loader是什么呢？

  - 用于对模块的源代码进行替换
  - css文件也可以看成是一个模块，通过 **import**来加载这个模块
  - 在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须制定对应的loader来完成这个功能

- 那么什么样的loader可以加载css呢？

  - 这个常用的loader最常用的是css-loader
  - 安装：`npm install css-loader -D`

- css-loader的三种使用方案：

  - 内联 

  <img src="./images/css_loader.png" alt="css-loader" style="zoom:50%;" />

  - CLI方式（webpack5中不再使用）
  - 配置方式 

  

- 有`css-loader`表示正常处理解析了css文件，但是解析之后的css文件没有插入到页面上。

- 想要插入style，就需要使用`style-loader`

  - `npm i style-loader -D `
  - use: ["style-loader"]
  - style-loader的原理就是在document.createElement(style)创建了个样式表

- 注意：webpack处理loader的时候是从下往上的，从右往左的



### 4.loader配置方式

- module.rules的配置如下：
- rules属性对应的值是一个数组 **[Rule]**
- 数组中存放的时 一个个的Rule，Rule是一个对象，对象中可以设置多个属性：
  - test属性：用于对resource（资源）进行匹配，通常设置成正则表达式
  - use属性：对应的值是一个数组：**[UseEntry]**，也是一个对象，有两个key
    - loader：指明要用哪些loader
    - options：可选属性，值可以使字符串或对象，值会被传入到loader中
  - `use:["css-loader"]`相当于键值对的写法

<img src="./images/rules.png" alt="rules" style="zoom:50%;" />

### 5.如何处理less文件？

#### 5.1安装相关工具

- 肯定是要把less转换成css的，需要安装less工具 `npm i less -D`

- 然后 `npx less ./src/css/component.less > component.css`即可转换成正常css文件

- 但是在正常开发中需要同时安装 **less** 和 **less-loader**  `npm i less less-loader -D`

  

#### 5.2配置相关rule（less）

<img src="./images/less.png" alt="less" style="zoom:50%;" />

## 二、第二章

### 2.1PostCSS工具

#### 2.1.1初识PostCSS

- 什么是PostCss？
  - PostCss是通过**JavaScript**来**转换样式**的工具
  - 这个工具可以帮助我们进行**CSS的转换和适配**，比如**自动添加浏览器前缀**，**css样式重置**
    - 需要添加前缀的样式网站是：`autoprefixer.github.io`
  - 实现这些功能，都需要借助于PostCSS对应的插件
- 如何使用PostCSS呢？主要就是两个步骤：
  - 先查找PostCSS在构建工具的扩展，比如webpack中的postcss-loader；
  - 选择可以添加你需要的PostCSS相关插件

#### 2.1.2命令行使用postcss

- 我们可以直接在终端中使用PostCSS，只需要单独安装一个工具`postcss-cli`
  - `npm i postcss -D`
  - `npm i postcss-cli -D` 目的是为了能在命令行中使用PostCSS
- 举个栗子：现在有个css文件里面有些样式，但是这些样式是需要加上浏览器前缀的
  - 现在这些样式是不行的，需要进行处理才能正常运行
  - `npx postcss -o result.css ./src/css/test.css`

![需要添加前缀的栗子](./images/testcss.png)

- 执行完上面命令行发现是有输出的，但是并没有添加前缀，是因为没有添加插件

![](./images/resultcss1.png)

- 想要自动添加前缀需要安装什么插件呢？
  - `npm i autoprefixer -D`
  - 然后再执行的时候也需要告诉这次你要使用的插件
    - `npx postcss --use autoprefixer -o result.css ./src/css/test.css`
  - 大功告成

![](./images/resultcss2.png)

#### 2.1.3在项目（webpack）中使用postcss

- 大致流程就是我们需要把自己写的css通过postcss转换成有前缀的result.css
- 然后再交给css-loader处理，渲染
- 首先需要安装 **postcss-loader**
  - `npm i postcss-loader -D`
- 然后需要在css-loader之前通过postcss-loader处理
  - 但要注意的是要使用对应的插件，上面也提到过

![使用postcss](./images/usepostcss.png)

**使用之前**

![](./images/before_postcss.png)

**使用之后**

![](./images/after_postcss.png)

#### 2.1.4postcss-preset-env的使用

- 上面介绍了 **autoprefixer**，但是很多项目中使用更多的是 **postcss-preset-env**
- 他的作用也是转换 **现代css特性**，让这个css可以被大多数浏览器识别
- 举个栗子：
  - 我们一般写16进制颜色的时候写6位：如 `#123456`, 代表着rgb
  - 但是我们写成8位 `#12345678` ,代表着 rgba，后面两个代表透明度
  - 但这个8位最新的浏览器确实可以解析，但是旧浏览器无法解析，而且上面使用的 **autoprefixer**也不会帮我们转换
  - 那怎么办? 答案就是使用 **postcss-preset-env**
- 使用步骤：
  - 安装： `npm i postcss-preset-env -D`
  - 在postcss-loader中使用该插件
- 使用之前效果：

![](./images/before_postcss_preset_env.png)

- 使用之后效果：

![](./images/after_postcss_preset_env.png)

- 这个css新特性就可以转换成大多数浏览器可识别的代码了

#### 2.1.5配置相关优化

- 在普通css中这样处理需要写一大推代码，项目中又有less有需要写一遍相同的代码，有没有办法优化？
- 将整个代码块直接改成像`css-loader`一样，写个字符串
- 把相关的插件依赖写到`postcss.config.js`里面，名字一定是要这个，不然无法读取
- 配置相关代码：

```js
module.exports = {
    pluginL [
    	require('postcss-preset-env')
    ]
}
```

#### 2.1.6 css-loader中importLoaders属性

- 有些场景是在一个样式中通过 **@import**引入另外一个css文件
- 这种情况就不会被 **postcss-loader**处理，需要为 **css-loader**添加 **importLoaders**属性
- 代码：

```js
{
	loader: "css-loader",
    options: {
		importLoaders: 1
    }
}
```

### 2.2mode配置

> mode有4中取值，默认是development，none，production等

#### 2.2.1 development

- 代表了开发模式，打包的js代码没有进行丑化

## 三、处理其他资源

- 在日常开发中，一个项目会依赖js，css文件，也还会依赖图片资源

### 3.1file-loader（处理其他文件资源loader）

- 要处理jpj、png等格式图片，我们也要有对应的loader：**file-loader**
  - file-loader的作用就是帮助我们处理 **import/require()**方式引入的一个文件资源，并且会将它放到我们输出的文件夹中；

#### 3.1.1使用file-loader

安装：`npm i file-loader -D`

配置规则：

```js
{
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: "file-loader"
},
```

这样就可以正常处理图片资源了。

**但是考虑一个问题，打包之后的图片资源名称是经md4加密后的哈希值，不方便 和原资源名称对应起来，想要对应起来，怎么做？**

#### 3.1.2对打包生成的图片资源重命名

- 这种重命名的方式也是vue脚手架的配置

```js
{
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'file-loader',
        options: {
          name: "[name].[hash:6].[ext]"
        }
      }
    ]
}    
```

**再来思考一个问题，图片资源有很多，打包后都默认放在build目录下，岂不是很不方便管理？想要把它放在对应的目录下，怎么做？**

#### 3.1.3打包后的文件放入对应的目录

- 在这里就是放在img目录下面，便于管理

```js
 {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'file-loader',
        options: {
          name: "[name].[hash:6].[ext]",
          outputPath: "img"
        }
      }
    ]
  }
```

### 3.2url-loader

- **url-loader**和 **file-loader**工作方式是相似的，但是可以将较小的文件转成base64的URI

#### 3.2.1 url-loader的使用

**安装** `npm i url-loader -D`

**配置代码** 

- 不会像 **file-loader**一样去生成图片，而是转换成 **base-64**直接嵌入到js文件当中

```js
 {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'url-loader',
        options: {
          name: "[name].[hash:6].[ext]",
          outputPath: "img"
        }
      }
    ]
  }
```

#### 3.2.2 url-loader带来的问题

- 一般比较适合于小文件的使用
- 如果是大文件的话，把base64代码直接嵌入到js文件当中会造成文件过大
- 意味着首次加载这个网页的时候需要花费更多的时间去下载这个js文件，造成白屏时间加长

#### 3.2.3 怎么决定如何使用url-loader和file-loader

- 首先肯定的是，大文件使用file-loader按图片格式打包，小文件直接转成base64
- 那么如何在配置文件中配置呢？

**配置文件**

- 该配置表示100kb作为一个分界点

```js
 {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'url-loader',
        options: {
          name: "[name].[hash:6].[ext]",
          limit: 100 *1024
        }
      }
    ]
  }
```

### 3.3 在webpack5中加载其他资源

> 在webpack5之前，会使用到 **raw-loader**、 **url-loader**、 **file-loader**。但是webpack5出来之后，我们可以直接使用资源模块类型（asset module type），来替代上面这些loader

**资源模块类型（asset module type）**，通过添加4种薪的模块类型，来替换所有这些loader：

- **asset/resource** 发送单独的文件并导出URL。之前对应的是 **file-loader**
-  **asset/inline** 导出一个资源的 data URI。之前通过使用 **url-loader**实现
-  **asset/source**导出资源的源代码。之前对应 **raw-loader**
- **asset**在导出一个data URI和发送一个单独的文件之间自动选择。之前通过 **url-loader**，并且配置资源体积限制实现。

#### 3.3.1使用asset module type模块

**安装** ：无需安装，直接使用。

**配置代码** ：

```js
  {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    type: "asset/resource"
  }
```

#### 3.3.2 指定存放目录

**方式一（在output中设置）**

```js
  output: {
    filename: "boundle.js",
    path: path.resolve(__dirname, "./build"),
    assetModuleFilename: "img/[name].[hash:6][ext]"  // 和file-loader不一样的地方，扩展名之前少一个.，模块帮我们加过了
  },
```

**方式二（在generator属性中设置）**

```js
  {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    type: "asset/resource",
    generator: {
      filename: "img/[name].[hash:6][ext]"
    }
  },
```

#### 3.3.3 大图片和小图片采用不同type打包

- 就是把大图片带走打包，小图片就转换为base64嵌入行内；
- 直接把 **type类型设置为asset**
- 设置parser属性中的maxSize

```js
  {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    type: "asset",  // 二选一打包 
    generator: {
      filename: "img/[name].[hash:6][ext]"
    },
    parser: {
      dataUrlCondition: {
        maxSize: 100 *1024
      }
    }
  },
```

### 3.4加载字体文件

> 很多场景下都会使用到特殊的字体或者字体图标，就会引入很多字体相关的文件，这些文件的处理方式都是一样的。
>
> 在webpack5之前也是通过file-loader来处理，但是在webpack5中就完全没必要了。

#### 3.4.1使用asset/resource加载字体文件

**安装** ： 无需安装

**代码配置** 

```js
  {
    test: /\.ttf|eot|woff2?$/i,
    type: "asset/resource",
    generator: {
      filename: "font/[name].[hash:6][ext]"
    }
  }
```



## 四、Plugin

### 4.1Plugin和Loader区别

> While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.

- 上面是webpack官方对plugin的描述，四级水平对其作个翻译：
  - Loader是用于特定的模块类型进行转换
  - Plugin用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等；

**举个简单的栗子说明loader和plugin的作用**

- css文件需要用css-loader去加载
- 但是多个css文件需要合并成一个就需要使用插件

<img src="./images/plugin_demo.png" alt="plugin栗子" style="zoom:75%;" />

**举个plugin使用的栗子**

- 不经过特殊处理的话，每次打包后的build文件夹，同名称的文件会被覆盖，但是多余文件不会被删除，
- 想要它删除多余文件，也就是重新生成新的build文件夹，该怎么做？

**安装** `npm i clean-webpack-plugin -D`

**导入** `const { CleanWebpackPlugin } = require('clean-webpack-plugin');`

**配置代码**

```js
plugins: [
  new CleanWebpackPlugin()
]
```

### 4.2 HtmlwebpackPlugin

- 在build中自动生成html文件去引入我们的css文件

#### 4.2.1 html插件的简单使用

**安装** `npm i html-wenpack-plugin -D`

**配置代码**

```js
plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
        title: "coderqmj webpcak app"
    })
]
```

- 这样做的话就可以打包之后在build生成HTML文件，根据模板引擎生成。
- 但是某些特除场景下提供的模板引擎无法满足需求，如vue中是需要把 组件挂载到`<div id="app"></div>`中的
- 所以我们还需要自定义模板引擎。

#### 4.2.2自定义模板引擎

- 首先需要在根目录下创建 **public**目录，在里面创建 **index.html**

**配置代码**

```js
plugins: [
    new HtmlWebpackPlugin({
        title: "coderqmj webpcak app",
        template: "./public/index.html"
    })
]
```

### 4.3定义全局常量DefinePlugin插件

#### 4.3.1使用DefinePlugin插件

- 由于这个是内置插件，无需安装，可以直接导入。

**配置代码**

- 改代码是配置网站图标的url全局变量

```js
// 导入
const { DefinePlugin } = require('webpack');
...
plugins: [
    new DefinePlugin({
       BASE_URL: '"./"'
    })
]
```

### 4.4CopyWebpackPlugin

- 在日常开发中，我们肯定是想要一些文件拷贝到我们dist文件夹里面
- 例如，网站图标，public里面的东西
- 那么我们就可以使用这个插件去实现

#### 4.4.1 拷贝插件的使用

**安装** `npm i copy-webpack-plugin -D`

**配置**

- 这样做技能复制public下面的文件，也能忽略复制对应的文件
- 需要注意的是，忽略配置的形式是 `**/文件名`

```js
// 导入
const CopyWebpackPlugin = require('copy-webpack-plugin');
...
new CopyWebpackPlugin({
  patterns: [
    {
      from: "public", // 从这个地方复制，to是默认在build文件夹下面的
      globOptions: {
        ignore: [
          "**/index.html",
          "**/.DS_Store"
        ]
      }
    }
  ]
})
```



## 五、模块化原理和source-map

### 5.1webpack模块化原理

- webpack打包代码，允许使用各种各样的模块化，但最常使用的是CommonJS，ESModule，它是如何帮助我们代码中实现模块化的呢？
- 我们可以来研究下它的原理，包括如下原理：
  - CommonJS模块化实现原理
  - ES Module实现原理
  - CommonJS加载 ES Module的原理
  - ES Module加载CommonJS的原理.

