## 二、webpack配置文件

### 1.打包过程

**指定入口出口打包方式一：命令**

`webpack --ebtry ./src/main.js --output-path ./build`

**指定出口入口方式二：配置文件（重点）**

```js
// webpack.config.js
const path = require('path');
module.exports = {
  entry: './src/main.js',
  output: {
    filename: "boundle.js",
    // 必须是绝对路径
    path: path.resolve(__dirname, "./build")
  }
}
```

00000000000000000000000000000000000000000000000**假如文件名不是webpack.config.js**

- 那就没有办法打包成功了，怎么办？
- 因为执行`webpack`命令时，会去查找`webpack.config.js`这个文件执行 
- 解决：
  - 在配置文件里面修改build指令的配置参数

![](./images/webpack_01.png)

### 2.webpack依赖关系图

- webpack到底是如何对我们的项目进行打包的呢？
  - 事实上webpack处理应用程序时，根据命令或已配置的文件找到入口
  - 入口开始，生成一个 **依赖关系图**，这个依赖关系图会包含应用程序中所需的所有模块（js，css，图片，字体）
  - 遍历图结构，打包一个个模块（根据文件的不同使用不同的loader来解析）
- 上述的例子：
  - 例子一：安装了某个第三方库`axios`，但是并没有使用，所以打包不会带进去，打包后总体积不会增大。
  - 例子二：项目中创建的文件，没有被引用，最后打包不会在依赖图上，所以体积也不会增大。
  - 例子三：假如有个js文件里面有函数，js确实被引用了，但是函数未被执行，函数也不会被打包。
    - 涉及到tree shaking 

###  3.代码编写案例

- 写了个css，导入到文件，最后把它打包，最后会报错，原因是缺少加载css的loader

- loader是什么呢？

  - 用于对模块的源代码进行替换
  - css文件也可以看成是一个模块，通过 **import**来加载这个模块
  - 在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须制定对应的loader来完成这个功能

- 那么什么样的loader可以加载css呢？

  - 这个常用的loader最常用的是css-loader
  - 安装：`npm install css-loader -D`

- css-loader的三种使用方案：

  - 内联 

  <img src="./images/css_loader.png" alt="css-loader" style="zoom:50%;" />

  - CLI方式（webpack5中不再使用）
  - 配置方式 

  

- 有`css-loader`表示正常处理解析了css文件，但是解析之后的css文件没有插入到页面上。

- 想要插入style，就需要使用`style-loader`

  - `npm i style-loader -D `
  - use: ["style-loader"]
  - style-loader的原理就是在document.createElement(style)创建了个样式表

- 注意：webpack处理loader的时候是从下往上的，从右往左的



### 4.loader配置方式

- module.rules的配置如下：
- rules属性对应的值是一个数组 **[Rule]**
- 数组中存放的时 一个个的Rule，Rule是一个对象，对象中可以设置多个属性：
  - test属性：用于对resource（资源）进行匹配，通常设置成正则表达式
  - use属性：对应的值是一个数组：**[UseEntry]**，也是一个对象，有两个key
    - loader：指明要用哪些loader
    - options：可选属性，值可以使字符串或对象，值会被传入到loader中
  - `use:["css-loader"]`相当于键值对的写法

<img src="./images/rules.png" alt="rules" style="zoom:50%;" />

### 5.如何处理less文件？

#### 5.1安装相关工具

- 肯定是要把less转换成css的，需要安装less工具 `npm i less -D`

- 然后 `npx less ./src/css/component.less > component.css`即可转换成正常css文件

- 但是在正常开发中需要同时安装 **less** 和 **less-loader**  `npm i less less-loader -D`

  

#### 5.2配置相关rule（less）

<img src="./images/less.png" alt="less" style="zoom:50%;" />

## 二、第二章

### 2.1PostCSS工具

#### 2.1.1初识PostCSS

- 什么是PostCss？
  - PostCss是通过**JavaScript**来**转换样式**的工具
  - 这个工具可以帮助我们进行**CSS的转换和适配**，比如**自动添加浏览器前缀**，**css样式重置**
    - 需要添加前缀的样式网站是：`autoprefixer.github.io`
  - 实现这些功能，都需要借助于PostCSS对应的插件
- 如何使用PostCSS呢？主要就是两个步骤：
  - 先查找PostCSS在构建工具的扩展，比如webpack中的postcss-loader；
  - 选择可以添加你需要的PostCSS相关插件

#### 2.1.2命令行使用postcss

- 我们可以直接在终端中使用PostCSS，只需要单独安装一个工具`postcss-cli`
  - `npm i postcss -D`
  - `npm i postcss-cli -D` 目的是为了能在命令行中使用PostCSS
- 举个栗子：现在有个css文件里面有些样式，但是这些样式是需要加上浏览器前缀的
  - 现在这些样式是不行的，需要进行处理才能正常运行
  - `npx postcss -o result.css ./src/css/test.css`

![需要添加前缀的栗子](./images/testcss.png)

- 执行完上面命令行发现是有输出的，但是并没有添加前缀，是因为没有添加插件

![](./images/resultcss1.png)

- 想要自动添加前缀需要安装什么插件呢？
  - `npm i autoprefixer -D`
  - 然后再执行的时候也需要告诉这次你要使用的插件
    - `npx postcss --use autoprefixer -o result.css ./src/css/test.css`
  - 大功告成

![](./images/resultcss2.png)

#### 2.1.3在项目（webpack）中使用postcss

- 大致流程就是我们需要把自己写的css通过postcss转换成有前缀的result.css
- 然后再交给css-loader处理，渲染
- 首先需要安装 **postcss-loader**
  - `npm i postcss-loader -D`
- 然后需要在css-loader之前通过postcss-loader处理
  - 但要注意的是要使用对应的插件，上面也提到过

![使用postcss](./images/usepostcss.png)

**使用之前**

![](./images/before_postcss.png)

**使用之后**

![](./images/after_postcss.png)

#### 2.1.4postcss-preset-env的使用

- 上面介绍了 **autoprefixer**，但是很多项目中使用更多的是 **postcss-preset-env**
- 他的作用也是转换 **现代css特性**，让这个css可以被大多数浏览器识别
- 举个栗子：
  - 我们一般写16进制颜色的时候写6位：如 `#123456`, 代表着rgb
  - 但是我们写成8位 `#12345678` ,代表着 rgba，后面两个代表透明度
  - 但这个8位最新的浏览器确实可以解析，但是旧浏览器无法解析，而且上面使用的 **autoprefixer**也不会帮我们转换
  - 那怎么办? 答案就是使用 **postcss-preset-env**
- 使用步骤：
  - 安装： `npm i postcss-preset-env -D`
  - 在postcss-loader中使用该插件
- 使用之前效果：

![](./images/before_postcss_preset_env.png)

- 使用之后效果：

![](./images/after_postcss_preset_env.png)

- 这个css新特性就可以转换成大多数浏览器可识别的代码了

#### 2.1.5配置相关优化

- 在普通css中这样处理需要写一大推代码，项目中又有less有需要写一遍相同的代码，有没有办法优化？
- 将整个代码块直接改成像`css-loader`一样，写个字符串
- 把相关的插件依赖写到`postcss.config.js`里面，名字一定是要这个，不然无法读取
- 配置相关代码：

```js
module.exports = {
    pluginL [
    	require('postcss-preset-env')
    ]
}
```

#### 2.1.6 css-loader中importLoaders属性

- 有些场景是在一个样式中通过 **@import**引入另外一个css文件
- 这种情况就不会被 **postcss-loader**处理，需要为 **css-loader**添加 **importLoaders**属性
- 代码：

```js
{
	loader: "css-loader",
    options: {
		importLoaders: 1
    }
}
```



## 三、处理其他资源

- 在日常开发中，一个项目会依赖js，css文件，也还会依赖图片资源

### 3.1file-loader（处理其他文件资源loader）

- 要处理jpj、png等格式图片，我们也要有对应的loader：**file-loader**
  - file-loader的作用就是帮助我们处理 **import/require()**方式引入的一个文件资源，并且会将它放到我们输出的文件夹中；

#### 3.1.1使用file-loader

安装：`npm i file-loader -D`

配置规则：

```js
{
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: "file-loader"
},
```

这样就可以正常处理图片资源了。

**但是考虑一个问题，打包之后的图片资源名称是经md4加密后的哈希值，不方便 和原资源名称对应起来，想要对应起来，怎么做？**

#### 3.1.2对打包生成的图片资源重命名

- 这种重命名的方式也是vue脚手架的配置

```js
{
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'file-loader',
        options: {
          name: "[name].[hash:6].[ext]"
        }
      }
    ]
}    
```

**再来思考一个问题，图片资源有很多，打包后都默认放在build目录下，岂不是很不方便管理？想要把它放在对应的目录下，怎么做？**

#### 3.1.3打包后的文件放入对应的目录

- 在这里就是放在img目录下面，便于管理

```js
 {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'file-loader',
        options: {
          name: "[name].[hash:6].[ext]",
          outputPath: "img"
        }
      }
    ]
  }
```

### 3.2url-loader

- **url-loader**和 **file-loader**工作方式是相似的，但是可以将较小的文件转成base64的URI

#### 3.2.1 url-loader的使用

**安装** `npm i url-loader -D`

**配置代码** 

- 不会像 **file-loader**一样去生成图片，而是转换成 **base-64**直接嵌入到js文件当中

```js
 {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'url-loader',
        options: {
          name: "[name].[hash:6].[ext]",
          outputPath: "img"
        }
      }
    ]
  }
```

#### 3.2.2 url-loader带来的问题

- 一般比较适合于小文件的使用
- 如果是大文件的话，把base64代码直接嵌入到js文件当中会造成文件过大
- 意味着首次加载这个网页的时候需要花费更多的时间去下载这个js文件，造成白屏时间加长

#### 3.2.3 怎么决定如何使用url-loader和file-loader

- 首先肯定的是，大文件使用file-loader按图片格式打包，小文件直接转成base64
- 那么如何在配置文件中配置呢？

**配置文件**

- 该配置表示100kb作为一个分界点

```js
 {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    use: [
      {
        loader: 'url-loader',
        options: {
          name: "[name].[hash:6].[ext]",
          limit: 100 *1024
        }
      }
    ]
  }
```

### 3.3 在webpack5中加载其他资源

> 在webpack5之前，会使用到 **raw-loader**、 **url-loader**、 **file-loader**。但是webpack5出来之后，我们可以直接使用资源模块类型（asset module type），来替代上面这些loader

**资源模块类型（asset module type）**，通过添加4种薪的模块类型，来替换所有这些loader：

- **asset/resource** 发送单独的文件并导出URL。之前对应的是 **file-loader**
-  **asset/inline** 导出一个资源的 data URI。之前通过使用 **url-loader**实现
-  **asset/source**导出资源的源代码。之前对应 **raw-loader**
- **asset**在导出一个data URI和发送一个单独的文件之间自动选择。之前通过 **url-loader**，并且配置资源体积限制实现。

#### 3.3.1使用asset module type模块

**安装** ：无需安装，直接使用。

**配置代码** ：

```js
  {
    test:/\.(png|jpg|jpeg|gif|svg)$/ ,
    type: "asset/resource"
  }
```

#### 3.3.2 指定存放目录

**方式一（在output中设置）**

```js
  output: {
    filename: "boundle.js",
    path: path.resolve(__dirname, "./build"),
    assetModuleFilename: "img/[name].[hash:6].[ext]"
  },
```

