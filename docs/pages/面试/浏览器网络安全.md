## 一、浏览器

### 1.输入URL到展示页面发生了什么？

```
1.首先判断这个URL是否合法（如何判断URL是否合法），如果不合法，则使用这个字符串进行搜索
2.判断是否资源有无缓存，有缓存则直接返回该资源，否则进入网络请求，第一步则需要DNS解析
3. DNS解析，把域名解析成IP地址（2.2）	
4. 为了请求资源，客户端和服务端建立TCP连接
5.SSL/TLS四次握手（只有https才有这一步）
3. 客户端发起HTTP请求
4. 服务器处理请求并返回数据
5. 浏览器接收数据并解析
6. 断开连接
```

### 2.HTML、CSS、JavaScript如何渲染页面

```
1.
```

### 3.浏览器优化，性能指标

```
```

### 4.浏览器安全，如何防御

```

```

### 5.用户刷新界面后，服务端如何判断这个用户还在登录状态

```
1.session
2.json web token
```

### 6.cookie和localstorage的区别

```
1.Cookie存储大小为4kb localStorage为5MB
2.cookie随浏览器关闭删除  localStorage永久存在，除非手动清除
3.每次请求都会发送到服务器  localStorage不会自动发送到服务器，仅在客户端访问
4.容易遭受到XSS攻击，支持 HttpOnly（不可以通过JS获取） 和 Secure（只在https传输） 属性。 localStorage容易受到XSS攻击，不支持额外的安全属性
5.cookie一般用于需要与服务器交互的数据，比如身份验证，跨页面保持用户登录
5.localStorage一般用于存储用户偏好，不需要频繁与服务器同步，非敏感数据的参数。
6.localStorage的安全性较差
```



## 二、网络

### 1.TCP三次握手

![](./images/tcp_01.png)

```
1.TCP三次握手的目的： 确保服务端和客户端都有发送和接受数据的能力、
2.tcp三次握手的流程：
	1.首先客户端发送SYN（请求建立连接，一般为1），和seq=x随机序列号到服务端，目的是告诉服务端想建立连接，并且告诉服务端我下一次接受确认序列号应该是多少
	2.服务端收到第一次的数据，并且发送ACK、SYN、seq=y、ack=x+1
	3.客户端收到第二次握手的数据并且发送ACK，seq=x+1，ack=y+1、
SYN：我要建立连接
ACK：没问题，可以进行连接
seq：数据包的序列号，标识
ack：下次对方应给我发送的序列号，值等于上一次的接受到的序列号+1
```

### 2.什么是DNS

```
概念：DNS（Domain Name System）是域名系统的英文缩写，是一个层次化、分散化的互联网连接资源命名系统，用于 TCP/IP 网络。
DNS的作用：
	1.识别主机的方式有主机名（域名）和IP地址；人类喜欢语义化的主机名，对于底层的计算机世界来说，它们更容易理解这个IP地址。为了同时满足人类和机器，所以我们需要一个能力：将主机名解析成IP地址的能力。那么DNS的作用就是这个，可以协助人类更方便地访问互联网
DNS解析流程：两种方式，递归和迭代
	1.首先在本地缓存中查找对应的IP
	2.递归查询：
		1.本地输入域名后，向本地域名服务器查询IP，如果没有，那本地域名服务器会向根域名服务器查询=>根向定居域名服务器查询
		2.如果在过程中查询到，然后由查询的末端层层返回到用户的主机
	3.迭代查询：
		1.本地主机向本地域名服务器发起递归查询
		2.本地域名服务器发起迭代查询，向根域名服务查询IP
		3，根域名服务器告诉本地域名服务器，下次应向顶级域名服务器查询的IP
		4.本地域名服务器向顶级域名服务器发起查询
		。。。
		5.某次中查到了，域名服务器将查询结果告诉本地域名服务器，然后本地域名服务器告诉本地主机
		
from：https://juejin.cn/post/7065238621866950693?searchId=20240417214723A331972EF5414F405A0A
```

### 3.什么是SSL/TSL

```
TSL: 传输层安全性协议 (Transport Layer Security) 前身是：安全套接层 (Secure Sockets Layer）

TLS目的/背景/解决的问题：
	1.目的是建立安全连接，保证数据的机密性和完整性
	2.
```
### 3.HTTPS加密过程

```
	1.客户端发起HTTPS请求
	2.服务端接收到HTTPS请求，在服务端创建好公钥私钥，并将包含私钥的数字证书发送给客户端
	3.客户端验证数字证书通过后在本地生成用于对称性加密的秘钥
	4.然后再客户端用服务端发送过来的公钥加密自己生成的密钥，发送给服务端
	5.之后双方的通信，都使用这个密钥来加密和解密数据
```

### 4.HTTP是什么？作用？

```
HTTP的概念：
	全称是超文本传输协议，是一个应用层协议，是网络通信的基础，用于客户端和服务器的数据交换。
作用：
	1.数据传输：可以在客户端和服务端之间传输文本，图片，视频等其他多媒体文件
	2.
```



### 5.浏览器缓存

```
强缓存：
	HTTPCache-Control首部和Expries首部，给每个文档添加一个过时日期，浏览器再次发起请求的时候，就会以当前时间和过期时间进行比对，没过期，命中，过期，就去服务器请求新鲜的数据.
	Cache-Control: max-age:可以设置最大使用时间，
	Expires:设置一个过期的日期，但是修改客户端的时间可以影响命中缓存，优先用cache

协商缓存：
	资源到期了，并不意味资源发生改变，没改变就无需再次发起请求。客户端和服务端可以通过某种验证机制去判断当前请求是否可以使用缓存。所以第一次请求的时候浏览器就会把响应头部的缓存标识保存起来。再次请求就会带上这个头部。服务器验证可用，就是304，不可用就是200

	Last-modified/If-Modified-Since：Last-modified服务端资源最后修改时间，由服务器响应给浏览器，浏览器将它保存为If-Modified-Since。再次发起请求就会比对这两个，一样就表示没修改过，返回304。不一样就是修改过了。返回200。

	Etag/If-None-Match：Etag是服务器生成的hash字符串，表示文件唯一标识符，在请求时由服务器发送给浏览器，浏览器保存为If-None-Match，再次发起请求时，会进行对比，一样就304，不一样200了

	区别：
		Etag精确度比Last-Modified高，因为修改时间变了，但是你内容没变，所以Etag更好
```

### 6.GET，POST,PUT的区别

```
```

### 7.TCP与UDP有什么区别？

```
1.TCP需要进行三次握手链接，数据传输完成需要四次挥手断开，UDP无需连接。
2.TCP保证了数据的可靠性，TCP在传输的过程中数据包会被编号，根据编号确保数据的完整性以及组装。如有丢包损坏，有重传机制。UDP会丢包
3.TCP具有流量控制和拥塞控制机制，防止网络过载；
4.TCP效率低，UDP效率高。
5.TCP需要握手挥手，网络开销大。UDP开销小。
6.TCP使用场景：可靠的数据传输，文件，电子邮件，网页等
7.UDP场景：直播，语音，在线游戏，等需要实时通信的应用

进阶：
1.TCP可以控制流量：当数据发送方的数据传输能力大于接受方的数据处理能力，需要控制流量了，防止信息丢失。
	1.通过滑动窗口：
		1.窗口大小：接收方在每个TCP的确认ACK中给出发送方的窗口大小，表示自己接收的最大数据量
		2.动态调整：窗口大小是实时调整的，根据当前的能力不断变化
		3.窗口滑动：发送方维护一个窗口，窗口的数据可以连续发送而不需要等待确认。随着接受方的确认到来，窗口向前滑动，发送新数据。

```





### 6.XSS&CSRF

```
一、XSS：跨站脚本攻击
	1.概念：黑客往HTML文件orDOM文件注入恶意脚本，从而在用户浏览页面时对用户进行攻击。一开始是跨域进行攻击，但是现在通过往HTML文件中注入恶意代码的方式很多，所以跨域注入脚本已经不是唯一手段。因无法识别恶意脚本还是自己的脚本，所以恶意脚本有普通脚本相同权限。
	2.攻击什么：
		1.窃取Cookie数据：
			恶意JS通过document.cooike获取cookie信息，可以模拟登录，进行转账；
		2.监听用户行为：
			JS可以通过addEventlistener监听键盘事件，输入账号密码等操作完全被监听。
		3.构建恶意DOM，比如假的登录页，让你输入账号密码
	3.怎么攻击：
		1.存储型XSS攻击：恶意脚本存储在有漏洞的服务器，用户访问，脚本获取信息，发送给黑客的服务器；
		2.反射型：用户在请求的时候，就把恶意脚本嵌入在请求链接提交给服务器，服务器又将恶意代码反射给浏览器。这就是XSS攻击。
			例子：通过QQ群，邮箱里面引诱用户点击的恶意链接。www.baidu.com?name=<script>alert('反射')</script>
		3.基于DOM的XSS攻击：不涉及服务器，黑客将恶意脚本注入页面，如WiFi网络，本地恶意软件劫持正在传输的HTML并且修改内容。
			- www.baidu.com?name=<button onClick="duckment.cookie">登录</button>
	4.怎么防御：
		反射型和存储型都和服务器交互，属于服务器漏洞；而基于DOM的XSS攻击是在浏览器端完成，属于前端安全漏洞；
		1.服务器漏洞：
			1.在服务端进行过滤或者转码，将script过滤，或者&lt;script&gt;所以等传给浏览器的时候就不会执行恶意代码；
			2.利用SCP：虽然转码有效果，但安全问题不能完全依赖服务端。SCP功能：
				1.是禁止下载其他域的资源文件
				2.禁止向第三方提交数据，所以用户数据不会外泄
				3.禁止执行内联脚本
				3.有上报功能，发现了XSS，及时修复；
			3.使用HTTPOnly：一般情况，XSS攻击是盗用cookie的，使用这个属性可以保护Cookie的安全；
				1.这样做的目的是让Cookie只在HTTP请求中使用，无法通过JavaScript来读取这段Cookie。
				2.document.cookie就无法读取到Cookie了
		  4.输入校验：
		  	1.限制输入长度，限制特殊字符串

二、SCRF——跨站请求伪造
	1.概念：黑客引诱用户打开网站，利用用户的登录状态发起跨站请求，也就是做一些坏事；
	2.攻击什么：利用用户登录状态做坏事
	3.攻击方式：
		1.自动发起Get请求：最容易的方式，通过可以跨域的标签，如<img src=“转账接口” />，到时候就会自动发起请求，完成转账；
		2.自动发起POST请求：有些接口是POST方法的，写一个隐藏form表单，到时候利用登录状态，直接执行submit，完成转账；
		3.引诱点击链接：比如点击下载什么美女图片啊，点了之后实际上就调用了转账接口，完成转账；
	4.如何防御：
		1.利用Cookie的SameSite属性： 因为Cookie具有维护浏览器和服务器的登录状态数据。
			1.该属性可以禁止第三方的Cookie发送；
			2.在HTTP响应头中，通过set-cookie字段设置cookie，可以带上SameSite选项；
			3.SameSite有三个值：
				1.Strict：完全禁止第三方
				2.Lax:相对宽松，第三方链接打开，第三方站点提交Cookie能携带Cookie，但是第三方Post，img，iframe都不会携带；
				3.None：完全不会禁止，任何情况都可以携带Cookie
		2.服务端验证请求的来源站点：判断是否第三方
			1.HTTP请求头中有Referer和Origin属性
			2.Referer记录HTTP请求的来源地址，但是有些时候暴露URL给服务器并不合适，所以选择不上传Referer；
			3.Origin属性：在XHR，Fecth发起请求，都会带上Origin（不含有路径信息）属性；
		3.CSEF Token
			除了上面两种，还可采用Token验证
			1.首先，在浏览器向服务器发起请求时，服务器生成一个CSRF Token（服务器生成的字符串），然后将字符串植入页面并返回；
			2.第二步，进行权限操作的时候就带上这个Token，然后验证Token是否合法；
			3.如何使第三方，那肯定是没有Token的，因为Token在页面中，必须要打开页面；
```

