### 1.如何做首屏资源加载优化，首屏加载的时间 如何统计、如何去优化，说思路

```
相关知识点：1.渲染流程；2.CSS、JS阻塞DOM；3.减少项目体积
1.什么是首屏时间？：用户完全不可交互的时间
2.什么是白屏时间？：出现第一个元素/图像花费的时间
1.如何计算首屏加载时间：(performance.timing.domComplete-performance.timing.navigationStart)/1000
2.如何计算白屏时间：
	(chrome.loadTimes().firstPaintTime - chrome.loadTimes().startLoadTime)*1000
	performance.timing.responseStart - performance.timing.navigationStart

如何优化：
	1.从优化角度一个页面的生命周期3个阶段：加载、交互、关闭，首屏优化总的来说就是加载优化
	2.首先分析渲染流程得出：
		1.图片，视频，音频这些文件不会阻塞我们页面的渲染
		2.JS、HTML、CSS会阻塞页面首次渲染，这些阻塞首次渲染的资源，叫做关键资源
	3.影响页面首次渲染的核心因素：
		1.关键资源数量：数量越多加载时间越长
		2.关键资源大小：关键资源越大，下载时间越长
		3.请求关键资源需要的RTT（Round Trip Time），从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延
			
	
	
```

### 2.渲染流程

```
大致流程：
  1.浏览器获取HTML文件，然后渲染进程（HTML解析器）通过一定的规则对文件进行解析转换，形成浏览器可以理解的DOM Tree
  2.与此同时，渲染引擎将css样式表进行解析，生成浏览器可以理解的StyleSheets，计算出DOM节点的样式
  3.接着将DOM Tree与Style Rules合成为布局树Render Tree。
  4.接着进入布局（Layout）阶段，也就是为每个节点计算并分配一个应出现在屏幕上的确切坐标。
  ==有了上面的坐标和样式，节点之类还不够，为了实现更复杂的样式效果，需要对展示的页面进行分层==
  5.随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来
    5.对布局树进行分层，生成图层树。（可以顺便说下下面1,2的分层规则和过程）
    6.每个图层生成绘制列表，实际上是一系列的绘制指令，并把这些指令交给合成线程。
    7.（可以先说下为什么要图块及概念）合成线程将图层分为图块（因为需要优先展示视口），在光栅化线程池中将图块转换为位图。
    8.一旦所有视口图块被光栅化生成位图，丰富的网页就展示在页面上了。
    
1.为什么要分层？（Layers）
 a.页面中有很多复杂的效果，3D转换，滚动，z-index之类的
 b.为了方便实现这些效果，渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树
 c.各个图层叠加才得到最终的图像
2.分层的规则（什么时候才会提升为图层树）
	a.不是每个节点都会被生成图层，不生成图层这个节点就属于父节点图层
	b.拥有层叠上下文属性的元素会被提升为单独的一层。
		1.明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
	c.需要剪裁（clip）的地方也会被创建为图层
		1.内容超出可视范围内，比如200*200的div里面有很多文字
3.如何绘制图层？
	a.会生成很多有顺序的绘制指令，这些指令就叫做待绘制列表，然后这些指令会交给合成线程
	b.这些指令被执行就生成了下一帧图片
4.一些概念：
	视口：用户当前可见部分叫做视口（viewport）
	图块：合成线程会将一个页面的图层划分为很多图块，通常是256*256或者512*512
	可视图块：视口所在的图块叫做可视图块
	位图：又称栅格图，是使用像素列阵来表示图像
5.图块是什么？为什么要有图块？
	a.因为有些时候一个网页很长，用户只能看到视口部分，绘制整个图层就显得没有必要，性能浪费
	b.优先去把视口的图块都生成位图
	c.生成位图的过程叫做栅格化，所以又叫栅格图，在GPU进程中执行并生成图块的位图，保存在GPU的内存中
6.有了图块的位图后怎么显示到页面？
	a.一旦所有图块被光栅化生成位图，丰富的网页就展示在页面上了。
	
布局树和DOM树的区别：
	1.布局树中只有当前需要展示的元素，那些display：none、script的元素是不需要的
	
```

### 3.DOM树如何生成

```
1.渲染引擎内部，有HTML解析器。解析过程是一边加载一遍解析的。
2.content-type判断文件类型，创建一个渲染进程，网络进程和渲染进程会有一个共享数据的管道。
3.网络进程输送数据，渲染进程中的HTML解析器读取数据
4.解析过程三个阶段：
	1.通过分词器将字节流转换为Token，分别是StartTag 文本Token EndTag 三个Token，放入栈中
	2.Token解析成DOM节点，DOM节点添加到DOM树中。HTML解析器有一个Token栈结构,用于解析父子关系，前面生成的Token压到这个栈中。
	3.压到栈中的是StartTag，解析器为该Token创建一个DOM节点，父节点就是栈中左边的元素。
	4.遇到的是 文本Token，生成文本节点，将该节点直接添加到DOM树种，无需压栈，父节点就是栈顶元素
	5.分词器解析出来的是EndTag，就和栈顶元素对比，比如 startTag div 和 EndTag div 匹配成功，则该div元素解析完成
这样，分词器不断压栈出栈，整个解析过程一直这样解析下去，直到分词器将所有字节流分词器完成。


```

### 4.JS如何影响DOM树

```
1.JS会阻塞DOM生成，读到<script>标签，HTML解析器会暂停工作，JS引擎介入执行，执行完成后才继续解析HTML生成DOM。
2.假如是 <script type="text/javascript" src='foo.js'></script>，从外部下载，需要下载完并执行，所以JS文件大小，网络环境会阻塞DOM解析。
3.Chrome的优化：预解析，加载HTML的时候，会开启预解析线程，分析html包含的js、css，会提前下载
3.个人优化：
	1.使用CDN加速、压缩JS体积；
	2.如果JS没有操作DOM，可以将该JS设置为异步加载：通过 async 或 defer 来标记
		async：脚本文件一旦加载完成，会立即执行
		defer：需要在 DOMContentLoaded 事件之前执行。
4.因为JS还可能操作CSSOM，所以要等CSS下载完成并且解析为CSSOM对象后，才能执行JS，所以JS又是依赖样式表

注意点：
	1.JS操作到未加载到的DOM时是不会生效的
```

### 5.前端数据缓存有哪些？有什么区别

|     特性     |                         cookie                         | session            |       localStorage       | sessionStorage |
| :----------: | :----------------------------------------------------: | ------------------ | :----------------------: | :------------: |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间，或者关闭窗口就消失 | 关闭生命周期就到期 | 除非被清理，否则一直存在 | 页面关闭就清理 |
| 数据存储大小 |                           4K                           | 4k                 |            5M            |       5M       |
| 与服务端通信 |             存放于浏览器，请求的时候会携带             | 存放于服务器       |          不参与          |     不参与     |
|    安全性    |                         不安全                         | 安全               |                          |                |
|     形式     |                         字符串                         | 对象               |                          |                |
|     应用     |                      登录、购物车                      | 登录、购物车       |                          |                |
|     跨域     |                        支持跨域                        | 不支持跨域         |                          |                |

### 6.浏览器缓存

```
强缓存：
	HTTPCache-Control首部和Expries首部，给每个文档添加一个过时日期，浏览器再次发起请求的时候，就会以当前时间和过期时间进行比对，没过期，命中，过期，就去服务器请求新鲜的数据.
	Cache-Control: max-age:可以设置最大使用时间，
	Expires:设置一个过期的日期，但是修改客户端的时间可以影响命中缓存，优先用cache
	
协商缓存：
	资源到期了，并不意味资源发生改变，没改变就无需再次发起请求。客户端和服务端可以通过某种验证机制去判断当前请求是否可以使用缓存。所以第一次请求的时候浏览器就会把响应头部的缓存标识保存起来。再次请求就会带上这个头部。服务器验证可用，就是304，不可用就是200
	
	Last-modified/If-Modified-Since：Last-modified服务端资源最后修改时间，由服务器响应给浏览器，浏览器将它保存为If-Modified-Since。再次发起请求就会比对这两个，一样就表示没修改过，返回304。不一样就是修改过了。返回200。
	
	Etag/If-None-Match：Etag是服务器生成的hash字符串，表示文件唯一标识符，在请求时由服务器发送给浏览器，浏览器保存为If-None-Match，再次发起请求时，会进行对比，一样就304，不一样200了
	
	区别：
		Etag精确度比Last-Modified高，因为修改时间变了，但是你内容没变，所以Etag更好
```

### 7.浏览器性能指标？

```
```



### 8.在项目中做过哪些优化？

```
```

