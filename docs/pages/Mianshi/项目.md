## 网易云

### 1.项目介绍

```
	使用了React编写的网易云PC Web项目，接口是来源于开源的项目，所以我觉得这是一个很好的练习项目，这样就可以把精力放在前端上，而不用烦恼数据的来源。
	本项目目前为止的话，搭好了项目的骨架。因为里面东西很多，也在陆续开发中，
	页面：推荐页面下面的轮播图展示，热门推荐，新碟上架，歌曲排行榜等等。
	
	业务功能：
		1.轮播图的滚动。
		2.点击歌曲，进行播放，并且添加到歌单里面
		3.根据歌曲的不同播放模式进行播放，随机、顺序、单曲。上一首下一首的播放与暂停。
		4.拖动进度条可以根据进度条的进度播放对应的位置
		5.点击播放模式可以更改播放模式，并且做出相应精灵图图标的变化
		6.歌词的展示
		
	学到的知识点：
		1.项目规范，项目文件夹划分的规范，变量名小驼峰，组件名大驼峰，常量大写
		2.写组件，整个项目都采用了函数式组件，并且全面HOOKS
		3.为了组件的不必要渲染，做了memo的包裹（浅层比较）;
		4.组件内部状态使用的是useState，useReducer，业务数据都放在redux管理，每个页面都有自己对应的				  reducer，然后把多个reducer进行合并共享在mian.js里面
		5.学到了styled-components书写样式，非常方便，嵌套，传参，表达式
		6.学到了axios的封装，请求相关数据
		7.学到了antd相关使用，轮播图，展示歌词的message。
		8.复用性组件的封装。
```

### 2.轮播图的滚动

```
	1.轮播图用的是antd里面的走马灯
	2.设置了autoplay自动播放
	3.用beforechange监听了滚动到哪一张轮播图，并且记录，回调函数(from,to),用useState记录改变
	4.监听了下一张上一张轮播图的点击事件。用ref然后bannerRef.current.prev() 
	5.高斯模糊：url后面拼接相关参数，就可以高斯模糊
	const bgImage = topBanners[currentIndex] && topBanners[currentIndex].imageUrl + "?imageView&blur=40x20"
```

### 3.redux存储请求数据

```
1.首先在src/services里面定义相关请求函数并导出；
2.在reducer里面定义相关的数组或者对象进行存储数据；
3.在常量文件定义相关常量
4.在reducer里面case相关常量，并且返回修改数据
case actionTypes.CHANGE_TOP_BANNERS:
      // return {...state,topBanners: action.topBanners} 原有的修改方式性能低
      return state.set("topBanners", action.topBanners)
5.在action文件里面定义相关的action， 和dispatch （action）的函数
6.在组件中使用useEffect/useDispatch对数据进行请求，useSelector对redux进行获取，然后使用。
```

### 4.播放功能

```
0.拿到歌曲：
	1.根据id可以获取到song的相关信息，播放链接，总时长，歌词信息等
	2.点击了加入歌单或者播放song的按钮，首先就回去判断歌单里面有没有该歌曲(通过id)，有的话改变currentIndex
	3.没有找到的话，就把该歌曲加入到歌单里面，歌单长度+1，同时设置那首歌的songIndex
	4.拿到id把audio的src设置为一个链接拼接id的播放链接
1.使用的是audio标签，还用了antd的slider进度条组件，使用了message展示歌词
2.有监听了四个播放相关按钮，下一首，上一首，暂停与播放。
	1.暂停与播放就是拿到audio的ref然后调用它自带的audioRef.current.pause()/play()
	2.上一首下一首传入参数-1/+1，然后dispatch相应的改变currentSong的action
3.监听进度条
	1.请求到的歌曲有总时间duration，
	2.onTimeUpdate监听获取到当前时间currentTime，按照比例关系用于展示进度条
	3.onEnded可以监听audio播放完，根据他的播放模式去改变当前歌曲，如果是单曲循环的话，currentTime设置为0，	  重新播放。如果是其他情况，就dispatch相关改变currentSong的action
4.播放模式
	1.单曲循环：进度条玩了后就把currentTime设为0，再play
	2.列表循环：
		1.currentSongIndex+1/-1就行：
		2.大于边界：currentIndex在最后一首，把currentIndex设为0；
		3.小于边界，说明current在第一首，上一首的话把currentIndex设为列表length-1
	3.随机播放：
		1.随机生成一个0-length-1的整数，
		2.while循环判断currentIndex是否等于随机数
		3.相等继续while循环，不相等就跳出while循环，把currentIndex设为随机数
```

### 5.歌词展示

![1598697187980](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1598697187980.png)

```
1.歌词是动态歌词展示的，每一个时间点展示对应的歌词，展示在antd里面的message组件里面
2.根据songId去请求数据，再使用工具类函数对歌词进行解析，得到歌词的数组，里面是对象，时间，content，再通过	dispatch action将歌词存放在reducer里面，在组件里将其取出来
3.展示当前歌词
	1.拿到所有歌词，是一个数组，数组里面是存放的是对象
	2.对象里面time属性代表歌词开始时间，content代表歌词内容
	3.用一个for循环，i从0开始，取出歌词列表的time和当前时间作对比
	4.当前时间<该歌词的开始时间，那么就应该展示上一句歌词
2.使用正则将歌词某时间点对应的歌词拿到
```

![1598696196089](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1598696196089.png)



### 6.项目中的优化

```
1.精灵图
	将多张图片合并到一起，减少了http请求，减少了项目中的总体积
	
2.项目全面采用函数式组件开发
	1.使用了memo进行了组件包裹，对函数式组件做了优化，避免做一些不必要的渲染。memo内部会对新旧props作比较，		  一样的话。就不会重新渲染，不一样就像渲染；
	2.项目中使用了useCallback（将函数缓存）
		1.第一个参数是函数，第二个是依赖
		2.场景：回调函数传给子组件使用，如果不使用useCallback就算包裹了memo，父组件更新导致函数重新生成了，			引用发生了变化，那么子组件就更新，没必要；所以使用useCallback缓存
		3.使用：在播放器组件下面的控制器组件里面有一个播放按钮，绑定了播放函数，避免了控制组件的重新渲染。
	3.项目中使用useMemo
		1.返回的也是一个记忆值，依赖不改变，那么记忆值不改变。
		2.场景：
			是让某个函数在依赖改变的情况下函数运行，避免函数运行的不必要开销

3.使用了ImmutableJs对redux修改进行了优化
```



## 二、购物商场

### 1.项目介绍

```
1.这个项目是使用vue框架开发的移动端项目；因为是移动端，页面的话有首页，分类页，商品详情页，购物车，个人信息等页面
	功能：
		1.轮播图的滚动
		2.使用了better-scroll，完成上拉加载更多，返回顶部这类的功能
		3.做了一个tabbar，点击它可以切换流行，热门新款等商品的数据；然后还有吸顶效果
		4.做了图片的懒加载
		5.做了底部的导航栏，点击它可以切换到不同的路由
		6.添加购物车的功能和提交订单
		
	用到的知识点：
		1.better-scroll
		2.父子组件的通信，非父子组件的通信；props，emit，eventbus，ref
		3.vuex进行状态管理，路由相关的知识；
		4.使用了防抖去优化监听鼠标的滚动事件
		5.使用了axios请求相关数据
		6.懒加载
```



### 2.轮播图

```

```

### 3.better-scroll

```
1.上拉加载
	1.本身自带PullingUp监听事件，触发把加载更多的函数emit发射事件出去，调用加载更多的函数，判断当前类型，就		  是把相关数据请求下来加入到对应的数组，去展示
	2.再去监听请求下来的图片是否加载完成，然后调用refresh的刷新页面

2.返回顶部
	1.在多个页面都使用，首页，详情页，之类需要下滑距离顶部很多的
	2.封装了一个复用的返回顶部组件，监听滚动事件，当滚动到一定位置时，就v-show让他展示
	3.点击它就会调用backTo函数，传入(0,0)就会返回顶部
```

### 4.商品类型栏&吸顶效果

```
1.商品栏(v-for生成都有index)，三种类型数据，传入不同的index，那个样式就变了，并且展示该index对应的数据，点	击子组件，就会emit到父组件去调用点击事件，判断传进来的index，记录当前类型就可以了

2.吸顶效果
	1.使用了两个商品类型栏(用一个的时候怎么调都掉不出来)。
	2.在nav-bar下面放一个同样的商品类型栏，默认v-show为false
	3.用bs自带的scroll滚动监听，参数有一个position，根据这个position.y去该组件是否达到顶部
	4.到达顶部的话，就让v-show为true就可以了
	4.从顶部滑下来，v-show又变为false
```

### 5.父子组件/非父子组件

```
1.商品类型栏
	商品类型栏是Home组件的子组件，在子组件里面监听点击的index，emit出去点击事件，在Home组件里面展示相关数据
```

### 6.图片的懒加载

```
1.使用了vue中的v-lazy，
2.使用了vant里面的lazyLoad，
```

### 7.添加购物车（vuex）/提交订单

```
1.使用了vuex，将商品的图片，价格等需要在购物车展示的信息存起来，用dispatch出去，然后在actions里面commit到	   mutations里面
2.加入购物车前，先判断vuex里面是否已经存在该id了，存在，则把count++再commit进去，没有的话，就设置count=1，   commit进去
3.展示数据的话就从vuex里面取出来mapGetters，mapMutations，取出相应的数据进行展示
4.提交订单的话就判断是选中商品，选中才能提交，checkedLength记录选中
```

### 8.防抖函数去优化刷新

```
1.因为要去监听图片的加载完成事件，加载完成之后调用refresh()重新计算可滚动区域高度，图片需要展示，
2.如果不用防抖优化的话，就会页面就会一直不停刷新，造成页面卡顿，用户体验差；
```

