### 1.你对VUE的理解

-  Vue是一套构建用户界面的渐进式框架（官网）
- 

- 数据驱动界面的库，vue是通过简单的API实现响应的数据绑定和组合的视图组件
- 

### 2.哪些生命周期干了什么在项目中

-  **beforeCreate**（创建前） 在数据观测和初始化事件还未开始
- created**（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
  **
- beforeMount**（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
  **
- mounted**（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。
  **
- beforeUpdate**（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
  **
- updated**（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
  **
- beforeDestroy**（销毁前） 在实例销毁之前调用。实例仍然完全可用。
  **
- destroyed**（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 

### 3. 操作cookie的方法 

-  request.getCookies():得到所有的cookie对象 
-  cookie.getName():得到此cookie对象的名字 
-  cookie.getValue(String name):得到对应名称的cookie的值 

### 4. cookie，localstorage，sessionstorage的区别，哪些情况适用哪个 

- **cookie**很小，4kb左右，保存登录信息（网站登录时保存密码），通常用于存储辨别用户的数据

- **localStorage**(HTML5)，将数据存储在本地的

- **sessionStorage**，作用与localStorage差不多，但是存储的时间不同，将以部分数据在当前会话保存下来，刷新页面的时候还存在，但是关闭页面时被清空。

-  localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 

- 应用场景：

  - cookie保存辨别用户信息的数据
  - localStorage用于保存HTML5游戏的本地存档
  - sessionStorage用于填写用户表单

- ## 三者的异同

  | 特性           | Cookie                                                       | localStorage                                                |                               sessionStorage |
  | :------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | -------------------------------------------: |
  | 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被手动清除，否则永久保存                                | 仅在当前会话下有效，关闭页面或浏览器后被清除 |
  | 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   |                                              |
  | 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |                                              |
  | 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                              |

### 5. 三次握手 

**三次握手的作用**：确保客户端和服务端两者都有发送和接收数据的功能，要完成此操作，需要最少的次数是三次

第一次：客户端发送syn报文和序列号Seq给服务端

第二次：服务端发送syn+ack（确认）报文，还有Seq序列号给客户端

第三次： 客户端发送ack报文，和Seq序列号

![三次握手](D:\Note\笔记图片\三次握手.png)

### 6. JavaScript事件流 

冒泡事件：微软提出，由具体元素到不具体

捕获事件：网景提出，由不具体到具体

通过addEventListener可以设置是哪一种事件流，第三个参数是是否捕获，true的话就是捕获流了

### 7. 宏事件微事件都有什么 

- macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
- micro-task(微任务)：Promise，process.nextTick

### 8. 项目中用到什么ES6的新特性 

箭头函数，map，reduce，filter

### 9. ES6转ES5 

babel

### 10. reduce函数 

两个参数，第一个回调函数，第二个是默认值。

回调函数有四个参数，prevValue，item，index, arr

返回值是每一次操作完成的值，下一次用到的第一个参数，prevValue

### 11. webpack了解吗 ？ 有修改过webpack吗为什么修改 ？

### 12. 前端优化 

### 13. 排序(只是问了知道哪些) 

###

