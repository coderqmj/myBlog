

### 1.验证Token

```
用到的东西：jwt，非对称性加密公钥私钥，使用openssl得到公钥私钥
1.首先在post方法里面添加验证登录和login中间件去让用户登录，验证后颁发token。
2.jtw.sign方法有三个参数，第一个对象（传了用户名和id），第二个私钥，第三个对象，配置了过期时间和加密算法，生成了token
3.然后再写一个验证权限的middleware，每次操作前执行。
	1.每次请求时都会带上token，将其取出来。
	2.使用jwt.verify方法，三个参数，(取出的token, 公钥, 相同的加密算法)，得到解密后的token
	
   const { id, name } = ctx.user;
    const token = jwt.sign({ id, name }, PRIVATE_KEY, {
      expiresIn: 60 * 60 * 24,
      algorithm: "RS256"
    });

```

### 2.怎么保证不可以同时登陆

### 3.怎么在Node中和MySQL结合起来的

```
1.使用的是koa框架，项目里安装了mysql2，并创建连接池，目的是多次数据库交互时不用每一次创建连接
2.创建的时候里面配置，host，user，密码，database，端口
3.交互方面：
	在src下面创建了用于数据交互的目录，评论交互，登录注册交互等文件。
	使用了预处理的语句提高性能（解析，优化，转换=>执行）与安全execute(传入参数)
	在里面执行数据库查询，删除，新增修改语句
4.然后再业务代码中调用导出的交互函数，比如登录，注册
```

## 二、Express

### 1.Express有哪些中间件

```
1.express.json()解析json
2.express.static('./build')存放静态资源的中间件
3.upload.any()上传文件中间件
```

## 三、V8引擎

### 1.V8引擎原理、JS执行流程

```
前置：
 1.V8引擎内置模块：Parse、Ignition、TurboFan
 2.解释型语言，效率相对较低，
JS执行流程：
	1.首先拿到JS源代码，内置模块Parse会将JS转换为AST抽象语法树。（为什么？因为我们的Ignition（内置模块解释器）不能够直接认识JS）
	2.Ignition解释器将语法树解释成字节码（类似汇编代码），字节码再进一步转成汇编，再转机器码，交给cup执行
	3.有热点函数的话，就走TurboFan模块转换为优化的机器码
V8做了哪些优化：
	1.为了提高JS的执行效率，如果一个函数被多次执行，那么就会重复AST->字节码->机器码，这样重复的过程有点浪费性能，为了优化，会把该函数标记为热点函数，并且在AST转换为字节码的过程当中，Ignition收集了一些优化信息（比如函数参数类型）
	2.有热点函数的话，就会通过TurboFan模块，将字节码直接转换成优化好的机器码。直接进行执行，之后再运行代码走这个过程效率会变高
		解释：同一个函数可能会被调用多次，那么到时候只是参数不同而已，函数本身就无需多次转换成机器码了，到时候直接使用第一次生成的机器码即可

缺点/问题：
	1.比如一个sum(num1, num2)函数，第一次传入的是数字，那么下次再转换成机器码的时候传入的参数也会被按照数字来处理。
	例子：第二次使用字符串，sum('AA','bbb'), 这个时候优化后的机器码就不知道如何执行了
解决(博客的图)：
	转换成机器码之后再多一笔操作，
	Deoptimization（反向优化）：
		在某些特殊的情况下，反向优化成字节码，再优化成机器码执行。
		
总结：
	1.开发的时候不要随意去更改传参类型，到时候会多进行反优化（就是需要将优化好的机器码转为字节码，然后根据新类型去生成对应类型的优化的机器码）的操作。
	2.会非常影响JS引擎的性能
	
面试：
	1.首先拿到JS源代码，通过V8内置模块将JS源代码转换为AST抽象语法树
	2.有了抽象语法树之后，在通过V8内置模块Ignition解释器将AST转换为字节码，并按顺序执行输出结果
	3.在转换的过程中，对于多次被执行的函数，会被解释器标记为热点函数，然后就会收集他们的参数类型信息，便于优化。
	4.如果有热点函数的话，就会使用V8内置模块TurboFan去优化生成优化的机器码，就无需浪费性能地再生成一遍字节码了。
	缺点：
		1.如果调用函数随意更改类型的话，如本来一个sum函数传的是number，在其他地方又传入string，这个时候就会触发反优化了，就是将机器码反向的编译成字节码，再让解析器去生成机器码去执行，所以开发过程中不规范的话，可能会影响JS的性能。
```



### 2.什么是AST，如何生成？AST的作用？

- 参见《浏览器实践与原理》04-14

```
什么是AST：
	1.像JS这种高级语言是我们开发者可以理解的语言，但是解释器和编译器是无法直接理解改语言的源代码的。
	2.对于编译器和解释器，他们可以理解AST，无论是解释型语言还是编译型语言，都需要将源代码转换为AST。
	3.个人的理解是AST是源代码的结构化表示，比如该树会告诉你定义了哪些变量，赋值是多少。定义的函数又是什么，返回值是多少等等
如何生成AST：一共2个阶段
	1.词法分析：将源码拆解成一个个的token，比如 let name = 'qmj'，关键字是let，标识符name，assignment（赋值运算符）是=，字符串'qmj'，四个都死token，而且他们的属性不一样。
	2.解析（parse）：又称语法分析，拿到词法分析的token数据，根据语法规则转为AST。
```

