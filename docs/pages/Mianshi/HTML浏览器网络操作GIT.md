## 一、计算机网络

### 1.http 与 https 区别

```\
http相当于在网络上裸奔         https就是穿了衣服。
http在传输数据的时候是明文的		https传输数据是经过SSL加密的
安全性低						         安全性高
不需要ca证书，成本低				    需要ca证书，需要一定的费用
80端口						           443端口
http无状态连接
```

### 2.七层/四层/五层协议

![七层协议](D:\Note\笔记图片\七层协议.png)

- 应用层： DNS/HTTP/FTP/SMTP
- 运输层：TCP/UDP

### 3.输入 url 到实现页面的过程

```
1.首先判断这个URL是否合法（如何判断URL是否合法），如果不合法，则使用这个字符串进行搜索
2.判断是否资源有无缓存，有缓存则直接返回该资源，否则进入网络请求，第一步则需要DNS解析
3. DNS解析，把域名解析成IP地址（2.2）
4. 为了请求资源，客户端和服务端建立TCP连接
5.SSL/TLS四次握手（只有https才有这一步）
3. 客户端发起HTTP请求
4. 服务器处理请求并返回数据
5. 浏览器接收数据并解析
6. 断开连接

详细：
	1.
```

### 4.base64 和 url 的区别

```
标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式.
```

### 5.base64

```
特点：
	1.便于网络传输
	2.不可见性
区分：
	1.base64是编码(encodeing) 而不是加密(encryption)
应用
	1.图片存储是2进制的，而不是文本形式，要传输他的话，要将2进制转为文本形式，这个时候就可以用base64
```

### 4.HTTP 状态码及其含义

- `1xx`:状态信息码
  - `100 continue` 继续
- `2xx`: 成功状态码(表示正常处理)
  - 200 OK
  - 201 请求成功并且创建了服务器资源
  - 202 服务器接受请求，但并未处理
  - 204 `No Content`成功但没有数据返回
- `3xx`重定向
  - `301 Moved Permanently` 永久重定向
  - `302 Found` 临时重定向
  - `304 Not Modified` 资源找到，但未符合条件
- `4xx` 客户端错误
  - `400 Bad Request` 服务器无理解请求的格式，不要再次发起请求
  - `401 Unauthorized` 未授权(未登录，无 token...)
  - `403` 禁止访问
  - `404` 找不到与 URI 匹配的资源
- `5xx` 服务器错误
  - `500 Internal Server Error` 最常见的错误
  - `503 Service Unavailable` 服务器暂时无法处理请求

### 5.HTTPS 加密过程，原理不大了解

```
原理->过程
1.客户端向服务器发起HTTPS请求
2.服务器创建公钥私钥，将包含公钥的数字证书发送给客户端
3.客户端对证书进行验证，验证通过后公钥将密钥进行加密
4.客户端将加密过后的密钥发送给服务器
5.服务器用自己的私钥对密钥进行解密
6.之后就通过对称性加密的方式进行加密通信
```

### 6.HTTP 缓存

```
强缓存：
	HTTPCache-Control首部和Expries首部，给每个文档添加一个过时日期，浏览器再次发起请求的时候，就会以当前时间和过期时间进行比对，没过期，命中，过期，就去服务器请求新鲜的数据.
	Cache-Control: max-age:可以设置最大使用时间，
	Expires:设置一个过期的日期，但是修改客户端的时间可以影响命中缓存，优先用cache

协商缓存：
	资源到期了，并不意味资源发生改变，没改变就无需再次发起请求。客户端和服务端可以通过某种验证机制去判断当前请求是否可以使用缓存。所以第一次请求的时候浏览器就会把响应头部的缓存标识保存起来。再次请求就会带上这个头部。服务器验证可用，就是304，不可用就是200

	Last-modified/If-Modified-Since：Last-modified服务端资源最后修改时间，由服务器响应给浏览器，浏览器将它保存为If-Modified-Since。再次发起请求就会比对这两个，一样就表示没修改过，返回304。不一样就是修改过了。返回200。

	Etag/If-None-Match：Etag是服务器生成的hash字符串，表示文件唯一标识符，在请求时由服务器发送给浏览器，浏览器保存为If-None-Match，再次发起请求时，会进行对比，一样就304，不一样200了

	区别：
		Etag精确度比Last-Modified高，因为修改时间变了，但是你内容没变，所以Etag更好
```

### 7.DNS 运行过程，DNS 性能优化的方法？

- **DNS 作用**

- 把域名解析成相应的 ip 地址

- **DNS 过程**

- 1.**递归查询**

  - ![1584711632672](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1584711632672.png)
  - 1.输入 **域名**后，**客户端**向**本地 DNS 服务器**要该域名的**IP 地址**。
  - 2.**本地 DNS 服务器**没有，本地 DNS 服务器找**根域名服务器**要.
  - 3.根域名服务器没有，根服务器找 A 顶级域名服务器要，逐级向下找
  - 4.找到后把该域名逐级返回到**客户端**，并保存到缓存，以备下一次使用

- 2.**迭代查询**

  - ![1584712482251](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1584712482251.png)
  - 全是客户端进行询问

- **总结**

  - 输入域名:arrow_right:操作系统检查本地 host 文件是否有映射关系 false？ :arrow_right: 客户端向本地 DNS 发起查询 :arrow_right: 采用递归查询或者迭代查询.

- **DNS 优化**

  - 减少`DNS`请求数量

    - DNS 查找数等于页面上不同的主机名数，包括页面 URL，图片，脚本文件，样式表等的主机名，减少不同的主机名就可以减少 DNS 查找

  - 缩短`DNS`请求时间

    - 预加载

      - `DNS Prefetch`让具有此属性的域名不需要用户点击链接就可以在后台解析，则域名解析和内容载入是串行的网络操作，减少等待时间.

      - ```html
        <link rel="dns-prefetch" href="//atanx.alicdn.com" />
        ```

### 8.HTTP0.9/1.0/1.1/2.0/3.0

```
1.HTTP0.9:
	1.就是请求+响应的模式，tcp三次握手连接+四次挥手断开连接
	2.没有请求头，请求体

2.HTTP1.0
	1.在HTTP1.0里面就可以展示多种文件类型，js，css，图片，视频，声音；
	2.在HTTP1.0里面可以设置请求头，响应头可以满足多种类型的数据传输
	3.accept：text/html accept-encoding：gzip， accept-Charset: ISO-8859-1,utf-8
	4.但是每一次请求数据都得进行一次连接和断开连接，消耗性能
	5.有缓存机制，引入了状态码，有用户代理（客户端基础信息，知道用户是windows还是MacOs）

3.HTTP1.1（HTTP1.1的补丁，虽然做了大量的更新）
	1.持久化连接（Connection默认开启）：多次请求数据则不需要断开连接；连接一次可以进行多次请求响应（减少服务器负担）；
	1.1.浏览器为每个域名最多同时维护6个TCP之久链接
	2.缺点：队头阻塞：只能上一次请求响应完成才会进行下一次请求；那么就有可能阻塞后面的请求
	3.引入Cookie：
	4.问题：对带宽的利用率低（tcp启动慢（3次握手，理解为0-100加速非常慢），开启多条tcp连接竞争带宽，队头阻塞）
	5.带宽竞争，有可能先请求了不重要的资源，而重要的关键资源（js+css+html）再后面请求到

4.HTTP2.0
	0.原因：tcp会竞争带宽，队头阻塞
	1.多路复用解决TCP竞争：就是一个域名只是用一个tcp长连接去传输数据，这样就不会竞争
	2.解决队头阻塞：正在执行的请求卡住就阻塞后面的，所以实现了资源并行请求，不按照顺讯返回，谁好了谁返回
	3.头部压缩：对响应头请求头进行了压缩，虽然单个头部不大，但是在大项目里面有几百个资源，如果把它们压缩到原来的20%，那也能提高很多性能
	4.设置请求的优先级，有些比较重要希望可以先对他进行请求

5.HTTP3.0
	1.
	缺点：
		1.还是存在TCP队头阻塞。
		2.因为只维持了一个TCP请求通道，解决慢启动问题，也可以不按顺序返回。
		3.如果TCP传输过程中丢包，那么就会影响后面所有请求，一直等到这个丢包的返回。如果是HTTP1.1起码还有其他5个TCP通道可以继续请求
		4.如果丢包率到2%的话，HTTP1.1的性能比HTTP2的性能好

5.HTTP3.0
	1.由于TCP启动慢，三次握手需要1.5个RTT+TLS需要1~2个RTT，所以传输数据之前要3~4个RTT，如果RTT>100ms，那用户体验很差了
	2.而且不能改进TCP了，因为TCP协议僵化，
		1.中间设备僵化：目前网络硬件设备几乎都是依赖于TCP协议，很难去升级TCP，如果客户端升级了，传输的过程中硬件识别不了，传输数据会丢失。
		2.操作系统僵化：因为TCP协议是通过操作系统实现，应用程序只能使用，不能修改
	3.TCP无法更新，只能绕过发明TCP和UDP之外的传输协议
		1.基于UDP实现了类似于TCP的多路数据流，传输可靠性等功能，命名为QUIC协议
		2.UPD传输没有可靠性，但是QUIC在UDP的基础上增加了一层，保证了数据传输的可靠性。提供了数据包重传，拥塞控制台等一些TCP特性
		3.集成TLS加密功能，使用TLS1.3，减少RTT个数
		4.实现了HTTP2多路复用功能：一个连接有多个独立的逻辑数据流，数据流单独传输，互不影响
		5.基于UDP，无需三次握手，减少RTT个数，3RTT => 0/1RTT(根据是否需要加密) 能快速请求数据渲染页面
```

### 9.tcp 和 udp 的区别，IP 和端口号的区别

```
1.TCP 面向连接的			UDP是无连接的
2.TCP安全性高			   UDP安全性低
3.效率低				     效率高
4.TCP具有数据包排序机制，把乱序的数据包还原成完整的文件	大文件被拆分成小数据包传输，UDP是不知道如何组装，就无法还原成完整文件
5.TCP数据包丢失提供重新传机制，保证了数据的完整性  UDP数据包传输的过程中会丢失，不会重新传

ip：负责把数据包交给主机
端口号：负责把数据包交给某一个具体的应用
```

### 10.知道哪些 content-type

```
1.text/plain		文本类型
2.text/css			css类型
3.text/html			html类型
4.application/json json类型
5.application/JavaScript js类型
```

### 11.HTTP 报文结构，有哪些 header

```
请求报文结构：
	1.请求行：请求方法（Method） + 空格 + 统一资源标识符（URI） + 空格 + HTTP版本 + CRLF
	2.请求头：字段名 + 冒号 + 值 + CRLF
		Referer：后面路径也带上
		Connection，Cookie，Origin，Content-Length
	3.空行： 回车符（CR）+ 换行符（LF
	4.请求体： 由用户自定义添加，如post的body等；


响应报文结构：
	1.状态行：HTTP版本 + 空格 + 状态码 + 空格 + 状态码描述 + CR LF ；
	2.响应头：字段名 + 冒号 + 值 + CR LF ；
		Access-Control-Allow-Headers，Connection，Content-Type，Set-Cookie
	3.空行： 回车符（CR）+ 换行符（LF） ；
	4.响应体： 由用户自定义添加，如post的body等；
```

### 12.HTTP 请求流程

```
构查备等连发
1.构建请求行，请求方法/请求URI/HTTP版本
2.在本地查找缓存，有就拦截请求，返回该资源副本，减少服务器压力
3.准备IP和端口：
	1.通过DNS解析域名，得到IP
	2.解析URL有无端口号，没有默认80
4.等待TCP队列
	1.一个域名6个连接，10个TCP请求的话，4个需要排队，少于6，则进入连接
5.建立连接
	三次握
6.发送HTTP请求
	建立连接之后，浏览器就可以和服务器通信
	请求数据格式：
		1.请求行：请求方法、请求URI、HTTP协议版本
		2.请求头：Host、Pragma、Cookie、Connection等等
		3.请求体

```

### 13.HTTP 响应流程

```
1.返回请求
 处理好请求返回数据给浏览器
2.关闭连接
 	一般情况下，直接关闭连接即可，但是如或有connection:keepAlive，就保持长连接，节省下一次的连接时间
3.重定向
```

### 14.第二次打开网页保持登录状态

```
1.使用了setCookie字段
2.第一次登陆成功，后端生成用户身份的字符串，保存响应头setCookie中，返回给前端。
3.浏览器解析响应头，遇到setCookie，保存在本地。
4.再次访问时，就会读取本地setCookie信息，并且在请求头把它带上发送给服务器
5.服务器验证，通过后把该用户的信息发送给浏览器
```

### 14.多个网站共享登录状态（单点登录）

```
在多个网站之间共享登录状态指的就是单点登录，多个应用系统中，用户只需要登录一次就可以访问所有互相信任的应用系统。

实现方法：将用户信息验证中心独立出来，作为一个单独的认证中心，这个认证中心用于判断客户端发送的账号秘法的正确性，然后向客户端返回对应的用户信息，并且返回由服务器端秘钥加密的登录信息的token给客户端，且具有时效性。当一个网站跳到另外一个时，通过url参数茶传递token，然后该网站把token传给认证中心，认证中心对token进行解密后验证，如果没失效，就返回用户对应的信息，失效则重定向。

概念：
	1.登录一次，多个应用同时登录，退出同理。
	2.用户登录一次，可以访问多个应用系统
优点：
	1.多个页面共享登录状态，不用记录每个平台的账号密码。
	2.用户操作简单，提高用户使用效率，提升体验
	3.降低管理成本，统一权限管理
原理：
	1.
```

### 15.网络的七层模型，各自有什么作用，为什么要进行分层

### 16 如果发起一个请求，又发起了一个请求，但是第一个请求的结果在第二个请求之后到达

```

```

### 17.TCP 三次握手，四次挥手

```
三次握手：确保双方都有发送和接收的能力

四次挥手：因TCP是全双工的，所以连接的拆除需要单独将两个通道分别拆除。
	1.如果是两次，那么会是半关闭状态，还有一端可以发送，另一端接收。
	以客户端主动发起为例：
		1.客户端发起请求给服务端，FIN标识（为1），客户端序列号N。
		2.服务端接收到包含FIN的请求消息后，校验无误后发确认请求ACK消息给客户端，ACK(1)，Seq=序列号N+1；
		3.服务端像上面一样做，断开另外一个通道
因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路
```

### 17.TLS 握手过程

### 18.简单请求非简单请求

```
简单请求：
	1.HTTP方法是下面之一：HEAD GET POST
	2.HTTP头部信息不超出以下几种字段：
		1.AcceptAccept
    2.Accept-Language
    3.Content-Type，但仅能是下列之一
      application/x-www-form-urlencoded
      multipart/form-data
      text/plain

```

### 18.数字证书中都包括哪些内容？

```
最简单的数字证书，包含一个公钥，名称，证书授权中心的数字签名。
```

### 19.HTTP2 头部压缩是如何实现的，多路复用的原理？

```

```

### 20.什么是字节流，什么是数据报

```
1.字节流：TCP
	我的理解是对数据传输的一种抽象化，让一端可以传输字节给另外一端的通信方式，一般都是双向的，是一种可靠的。
2.数据报：
	我的理解是他就是UDP，传输方式，无需连接即可传输数据，但是不这么可靠
```

### 21.http 请求的幂等概念的理解以及常见请求的幂等性

```
1.文档：相同的请求执行多次和执行一次的副作用是一样的。
2.幂等的方法有哪些：
	GET，HEAD，PUT，DELETE，OPTIONS 和 TRACE 方法都是幂等的。
3.但POST不是幂等的，常用于修改资源，就不满足传入同一个参数，返回结果不一样了
```

### 22.HTTP 的 option 预请求

```
与head类似，是客户端用于查看服务器的性能 。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。
1.获取服务器支持HTTP请求方法；黑客比较常用
2.检查服务器性能，跨域时，向另外一个域名发送options请求头，可以判断发送的请求是否安全。
3.属于复杂请求；
```

### 23.什么是 CDN，如何查找最近的

```
CDN：内容分发网
将网站的内容发布到最接近用户的站点，让用户就近获取资源，避免了网络拥塞情况，提高响应速度。解决了网络单宽小，用户访问量大等问题。

根据用户的IP地址，去寻找一台离用户最近的服务器。
```

### 24.为什么 TCP 是可靠传输

```
1.TCP具有数据重传机制：
	TCP不像UDP在传输数据过程中会丢包，每发出一个数据包，都会有一个确认接收，超过一定时间，会被判断成没有接受到，会重新发送
2.具有编排序号能力
	将传输数据分为各个小数据包，传到浏览器，能拼接成完整的数据
```

### 25.介绍下 websocket

### 26.TCP 头部大小是固定的吗？

### 27.WebSocket 如何连接？服务端给客户端发送的 http 状态码是什么？

### 10.503

### 28.数据包传输的过程

```

```

## 二、HTML

### 1.H5 标签

```
header/footer/article/nav/section/video/audio/canvas
```

### 2.get 和 post

```
浏览器：
	get用于请求资源		post用于提交表单
	get参数url可见		 post参数不可见
	get请求可以缓存		post请求不可以缓存
	get数据一般2-4k		 post请求传输数据大小php.inis设定
	get一般用于查询的数据 post用于添加修改删除之类的。
	get安全性低一点			post安全性比get高   解释：登录传参 get=>login?name='qmj'&password=123
```

### 3.post 数据类型

```
1.application/x-www-form-urlencoded(最常见)
	原生表单，不设置enctype，就用这种方式

2.multipart/form-data(常用)
	必须让表单的enctype等于multipart/form-data

3. application/json

4.text/xml
```

### 4.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

- 行内元素有：`a b span img input select strong`
- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`
- 空元素： `<br> <hr> <img> <input> <link> <meta>`
- 行内元素不可以设置宽高，不独占一行
- 块级元素可以设置宽高，独占一行

### 5. Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?

- `!DOCTYPE html`位于文档的最前面，告诉浏览器的解析器用什么规范去解析这个文档

### 6.操作节点(Node)的方法

```
1.appendChild		添加节点
2.removeChild		删除节点
3.replaceChild		替换几点		返回被替换节点
4.hasChildNodes		是否有子节点	   返回布尔值
```

### 7.DOMContentLoaded 和 load 区别

```
DOMContentLoaded：
	当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完全加载。
load:
	整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。
```

### 8.HTML5 新特性

```
1.语义化标签
	header，footer，article，nav，audio，video
2.2D/3D:
	canvas，svg
3.多媒体
	audio、video
4.离线存储
	localStorage，sessionStorage，indexDB
```

### 9.querySelector 可以选择伪元素吗

```
不能，MDN上面查过，注意事项里面提到CSS伪类，伪元素无法返回任何元素
```

### 10.前端渲染和后端渲染区别

```
服务端渲染：
	由后端去管理路由的匹配，每个url在后端对应一个资源，在后端渲染好再展示到前端上。
	服务器做的事情：
		url发送到服务器，服务器自己正则匹配，控制器处理生成HTML和数据，返回给前端

前端渲染：
	由前端进行路由匹配规则，history和hash模式。
	html，css，js资源都是由静态资源服务器返回的。
	数据通过接口进行请求，由后端返回数据。
```

## 三、浏览器

### 1.跨域

```
1.jsonp
	利用浏览器没有跨域限制的漏送，通过script指向要访问的地址，
	并提供一个回调函数去接收通讯时接收的数据。
	但是只限用于get请求

2.cors
	这个需要前后端同时支持，前端会自动实现，关键在于后端，服务端
	设置：
		Access-Control-Allow-Origin 就可以开启CORS
		Access-Control-Allow-Headers
		Access-Control-Allow-Methods 哪些方法

3.document.domain
	该方式只能用于二级域名相同的情况下，如：a.test.com与b.test.com
	只要给页面添加document.domain='根域名'
```

### 2.浏览器缓存机制

### 3.如何进行网站的性能优化

- https://juejin.cn/post/7173865309185671181
- https://juejin.cn/post/6915204591730556935

```
1.请求HTML数据和构建DOM中间有空闲时间，是瓶颈
2.看到有些代码是同时需要请求多个接口的数据，比如该机器下面的，TDSQL，Redis，CBS等信息，使用了线性请求，应该用并发
3.关键资源使用preload，可以提升资源加载优先级，在网络资源加载面板可以看到，关键资源优先请求
4.prefetch 则是用于加载未来（比如下一个页面）会用到的资源，并且告诉浏览器在空闲的时候去下载，它会将下载资源的优先级降到最低。

**三件套+server+图片**

- `content`方面
  - 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名
  - 减少`DOM`元素数量
  - 使用 iconfont
  - 删除不必要的元素
- `Server`方面
  - 使用`CDN`
  - 配置`ETag`
  - 对组件使用`Gzip`压缩
- `css`方面
  - 将样式表放到页面顶部
  - 不使用`CSS`表达式
  - 使用`link`，不使用`@import`
  - 避免使用表格
- `Javascript`方面
  - 将脚本放到页面底部 （自上而下的，先优先加载内容和样式，再去解析脚本）
  - 将`javascript`和`css`从外部引入
  - 压缩`javascript`和`css`
  - 删除不需要的脚本
  - 减少`DOM`访问 (重排、重绘，消耗 CPU)
- 图片方面
  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化`css`精灵
  - 不要在`HTML`中拉伸图片

### 
```

### 4.浏览器渲染 UI

```
大致流程：
  1.首先是构建DOM树：浏览器获取HTML文件，然后渲染进程对文件进行解析转换，转换浏览器可以理解的DOM Tree（几乎和HTML一模一样，但是可以通过js修改）
  2.第二步计算样式，渲染引擎将css样式表进行解析，生成浏览器可以理解的StyleSheets，然后还需要标准化样式表中的属性值（比如2em、blue、bold，渲染引擎理解不了，需要转rgb，转具体的值），再计算出每个DOM节点对应的样式（如何计算，见7）
  3.接着进入布局（Layout）阶段，就是计算出DOM树中可见元素的在屏幕上的位置。
  	3.1 创建布局树：遍历DOM树中所有可见的节点，把这些节点加到布局中，忽略不可见元素，如 display: none，还有
  	3.2 布局计算：有了完整的布局树，计算出布局树中的坐标位置。
  4.有了布局树，并且每个元素的具体位置也计算出来了，还不能开始绘制图像，因为页面中有很多复杂的效果，3D转换，页面滚动，或者有z-index，为了方便实现这些效果，渲染引擎会给这些节点生成专用的图层，并生成图层树，正是这些图层叠加在一起才生成最终图像
  5.分层：
  	5.1不是每一个布局树的节点都有自己的图层，一个节点没有对应的图层，那这个节点就属于父节点的图层。
  	5.2拥有层叠上下文属性的元素会被提升为单独的层，页面虽然二维，但是层叠上下文可以让html有三维的概念，z-index，定位，透明等样式都可以让元素有层叠上下文
  	5.3需要裁剪的地方会被创建图层，比如文字内容大于div盒子了，就会创建图层。
  6.接下来进行图层绘制：渲染引擎会对每个图层进行绘制
  	6.1渲染引擎把一个图层生成对应绘制指令列表，然后把这些指令提交到合成线程
  合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
  合成线程发送绘制图块命令DrawQuad给浏览器进程。
  浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

  5.对布局树进行分层，生成分层树。（可以顺便说下下面1,2的分层规则和过程）
  6.每个图层生成绘制列表，实际上是一系列的绘制指令，并把这些指令交给合成线程。
  7.（可以先说下为什么要图块及概念）合成线程将图层分为图块（因为需要优先展示视口），在光栅化线程池中将图块转换为位图。
  8.一旦所有视口图块被光栅化生成位图，丰富的网页就展示在页面上了。

1.为什么要分层？（Layers）
 a.页面中有很多复杂的效果，3D转换，滚动，z-index之类的
 b.为了方便实现这些效果，渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树
 c.各个图层叠加才得到最终的图像
2.分层的规则（什么时候才会提升为图层树）
	a.不是每个节点都会被生成图层，不生成图层这个节点就属于父节点图层
	b.拥有层叠上下文属性的元素会被提升为单独的一层。
		1.明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
	c.需要剪裁（clip）的地方也会被创建为图层
		1.内容超出可视范围内，比如200*200的div里面有很多文字
3.如何绘制图层？
	a.会生成很多有顺序的绘制指令，这些指令就叫做待绘制列表，然后这些指令会交给合成线程
	b.这些指令被执行就生成了下一帧图片
4.一些概念：
	视口：用户当前可见部分叫做视口（viewport）
	图块：合成线程会将一个页面的图层划分为很多图块，通常是256*256或者512*512
	可视图块：视口所在的图块叫做可视图块
	位图：又称栅格图，是使用像素列阵来表示图像
5.图块是什么？为什么要有图块？
	a.因为有些时候一个网页很长，用户只能看到视口部分，绘制整个图层就显得没有必要，性能浪费
	b.优先去把视口的图块都生成位图
	c.生成位图的过程叫做栅格化，所以又叫栅格图，在GPU进程中执行并生成图块的位图，保存在GPU的内存中
6.有了图块的位图后怎么显示到页面？
	a.一旦所有图块被光栅化生成位图，丰富的网页就展示在页面上了。
7.样式如何计算
	-涉及到样式继承和样式层叠规则
	-CSS继承，每个DOM节点都包含父节点的样式，优先使用自己的或者最近祖先的
	-样式层叠：层叠是CSS基本特征，是一个如何合并多个源的属性值的算法，

总结：
口令：HTML转，CSS转，Layout，合成，根据指令绘制
渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
创建布局树，并计算元素的布局信息。
对布局树进行分层，并生成分层树。
为每个图层生成绘制列表，并将其提交到合成线程。
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
合成线程发送绘制图块命令DrawQuad给浏览器进程。
浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

```

### 5.cookie 和 localSrorage、session、indexDB 的区别

|     特性     |                         cookie                         | session            |       localStorage       | sessionStorage |
| :----------: | :----------------------------------------------------: | ------------------ | :----------------------: | :------------: |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间，或者关闭窗口就消失 | 关闭生命周期就到期 | 除非被清理，否则一直存在 | 页面关闭就清理 |
| 数据存储大小 |                           4K                           | 4k                 |            5M            |       5M       |
| 与服务端通信 |             存放于浏览器，请求的时候会携带             | 存放于服务器       |          不参与          |     不参与     |
|    安全性    |                         不安全                         | 安全               |                          |                |
|     形式     |                         字符串                         | 对象               |                          |                |
|     应用     |                      登录、购物车                      | 登录、购物车       |                          |                |
|     跨域     |                        支持跨域                        | 不支持跨域         |                          |                |

### 6.Chrome 优点

```
1.具有预解析操作：
	之前如果文件中出现js、css外部文件时，需要下载，就会耗费时间，从而导致DOM阻塞。
	现在会启动预解析线程，分析HTML文件有无外部引入文件，从而提前下载
```

### 7.阻塞渲染问题

```
1.css解析成CSSOM，html解析生成DOM，生成渲染树。
2.JavaScript阻塞DOM生成：
	1.因为JavaScript要操作DOM
	2.可以使用defer(contentLoaded事件前)和async(加载完立马执行)去优化，使js文件异步加载
3.css阻塞js执行，但是不阻塞js加载：
	1.因为js要操作css，需要依赖样式表
	2.所以css也有可能会阻塞dom生成
	3.前提是样式表放在前面，在后面的话，css解析就不会并行了

1.js会阻塞页面的渲染：
	原因：DOM需要等待JS加载并执行完成才能继续解析：
    1.因为JS可能会修改DOM结构，页面的设计是先让JS加载执行，然后再去解析DOM。这样确保页面的结构是JS执行想要的，不然DOM先加载，再执行JS会出现页面闪烁的效果，用户体验降低。（如果有setimeout，则还是会出现闪烁）
    2.提升性能，避免重排重绘，因为先渲染再执行JS的话，多个地方对DOM结构进行操作，可能会引起频繁的重排重绘。导致用户体验差
  优化：
  	1.使用defer属性，确保脚本在HTML解析完成后按顺序执行，不阻塞页面渲染，会在DOMContentLoaded时间之前执行
		2.async 属性：使脚本异步加载并执行，不阻塞DOM，但不能保证执行顺序，哪个先加载完成，哪个立即执行。

备注：
	1.DOMContentLoaded 事件是在文档被完全解析后但样式表、图片和子框架等资源可能还没有完全加载完成时触发的。

2.CSS阻塞DOM的渲染：
	1.渲染流水线上看，就是要加载完并解析转换成styleSheets才能合成布局树进行渲染。
	2.这么设定也是可以防止重排重绘，增加渲染成本和用户等待时间
	如何优化减少阻塞：
		1.压缩css文件，减少加载时间
		2.异步加载非关键css


1.浏览器解析遇到 CSS样式资源 时，CSS会异步下载，不会阻塞浏览器构建DOM树，但是会阻塞渲染，在构建渲染树时，会等css下载解析完毕后才进行（防止css规则不断变化）
2.浏览器解析遇到 JS脚本资源 时，需要等待JS脚本下载完成并执行后才会继续解析HTML；但是当脚本加上defer与async时又不一样，defer是延迟执行，async是异步执行；
3.CSS加载会阻塞后面的的JS语句的执行，因为HTML5标准中有一项规定，浏览器在执行Script脚本前，必须保证当前的的外联CSS已经解析完成，因为JS可能会去获取或者变更DOM的CSS样式，如果此时外联CSS还没解析好，获取到的结果就是不准确的；
4.解析遇到 Img图片 时，直接异步下载，不会阻塞解析；下载完毕后用图片替换原有src的地方；
总结：
CSS 会阻塞浏览器渲染；
JS 会阻塞浏览器解析；
CSS 会阻塞后面的JS执行；
IMG 不会阻塞；
```

### 8.如何生成 DOM？什么是DOM？

```
1.渲染引擎内部，有HTML解析器。解析过程是一边加载一遍解析的。
2.content-type判断文件类型text/html，创建一个渲染进程，网络进程和渲染进程会有一个共享数据的管道。
3.网络进程输送数据，渲染进程中的HTML解析器读取数据
4.解析过程三个阶段：
	1.通过分词器将字节流转换为Token，分别是StartTag 文本Token EndTag 三个Token，放入栈中（计算父子关系）
	2.Token解析成DOM节点，DOM节点添加到DOM树中。HTML解析器有一个Token栈结构,用于解析父子关系，前面生成的Token压到这个栈中。
	3.压到栈中的是StartTag，解析器为该Token创建一个DOM节点，父节点就是栈中左边的元素。
	4.遇到的是 文本Token，生成文本节点，将该节点直接添加到DOM树中，无需压栈，父节点就是栈顶元素
	5.分词器解析出来的是EndTag，就和栈顶元素对比，比如 startTag div 和 EndTag div 匹配成功，则该div元素解析完成
这样，分词器不断压栈出栈，整个解析过程一直这样解析下去，直到分词器将所有字节流分词器完成。

什么是DOM？
	1.渲染引擎无法识别HTML，所以要把html转为渲染引擎可以理解的的数据结构，也就是DOM
	2.从页面角度看，DOM就是生成页面的基础数据结构
	3.从JS角度看，DOM提供给了JS操作的接口，通过这套接口，JS对DOM结构访问，从而改变文档结构、样式和内容
	4.从安全角度看，DOM是一套安全防护线，不安全的东西在解析阶段就被过滤了？
		例子：
			1.
	5.总结：DOM是表述HTML的数据结构，将Web页面和JS脚本连接起来，并且过滤一些不安全的内容
```

### 9.减少白屏时间

```
白屏原因：
1.页面是需要布局树渲染的，那么JS，和CSS都会阻塞dom解析，所以会影响布局树的生成。
2.如果DOM解析完成，这个时候CSS文件还没开始下载，那这样渲染进程就无事可做了（因为需要CSSOM生成布局树），会导致白屏时间加长

解决办法：
	1.通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件 之后就可以直接开始渲染流程了。
  2.但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等 工具移除一些不必要的注释，并压缩 JavaScript 文件。
  3.还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
  4.对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这 样只有在特定的场景下才会加载特定的 CSS 文件。
```

### 10.浏览器安全 XSS，CSRF

```
一、XSS：跨站脚本攻击
	1.概念：黑客往HTML文件orDOM文件注入恶意脚本，从而在用户浏览页面时对用户进行攻击。一开始是跨域进行攻击，但是现在通过往HTML文件中注入恶意代码的方式很多，所以跨域注入脚本已经不是唯一手段。因无法识别恶意脚本还是自己的脚本，所以恶意脚本有普通脚本相同权限。
	2.攻击什么：
		1.窃取Cookie数据：
			恶意JS通过document.cooike获取cookie信息，可以模拟登录，进行转账；
		2.监听用户行为：
			JS可以通过addEventlistener监听键盘事件，输入账号密码等操作完全被监听。
		3.构建恶意DOM，比如假的登录页，让你输入账号密码
	3.怎么攻击：
		1.存储型XSS攻击：恶意脚本存储在有漏洞的服务器，用户访问，脚本获取信息，发送给黑客的服务器；
		2.反射型：用户在请求的时候，就把恶意脚本嵌入在请求链接提交给服务器，服务器又将恶意代码反射给浏览器。这就是XSS攻击。
			例子：通过QQ群，邮箱里面引诱用户点击的恶意链接。www.baidu.com?name=<script>alert('反射')</script>
		3.基于DOM的XSS攻击：不涉及服务器，黑客将恶意脚本注入页面，如WiFi网络，本地恶意软件劫持正在传输的HTML并且修改内容。
	4.怎么防御：
		反射型和存储型都需要经过服务器，属于服务器漏洞；而基于DOM的XSS攻击是在浏览器端完成，属于前端安全漏洞；
		1.服务器漏洞：
			1.在服务端进行过滤或者转码，将script过滤，或者&lt;script&gt;所以等传给浏览器的时候就不会执行恶意代码；
			2.利用SCP：虽然转码有效果，但安全问题不能完全依赖服务端。SCP功能：
				1.是禁止下载其他域的资源文件
				2.禁止向第三方提交数据，所以用户数据不会外泄
				3.禁止执行内联脚本
				3.有上报功能，发现了XSS，及时修复；
			3.使用HTTPOnly：一般情况，XSS攻击是盗用cookie的，使用这个属性可以保护Cookie的安全；
				1.这样做的目的是让Cookie只在HTTP请求中使用，无法通过JavaScript来读取这段Cookie。
				2.document.cookie就无法读取到Cookie了

二、SCRF——跨站请求伪造
	1.概念：黑客引诱用户打开网站，利用用户的登录状态发起跨站请求，也就是做一些坏事；
	2.攻击什么：利用用户登录状态做坏事
	3.攻击方式：
		1.自动发起Get请求：最容易的方式，通过可以跨域的标签，如<img src=“转账接口” />，到时候就会自动发起请求，完成转账；
		2.自动发起POST请求：有些接口是POST方法的，写一个隐藏form表单，到时候利用登录状态，直接执行submit，完成转账；
		3.引诱点击链接：比如点击下载什么美女图片啊，点了之后实际上就调用了转账接口，完成转账；
	4.如何防御：
		1.利用Cookie的SameSite属性： 因为Cookie具有维护浏览器和服务器的登录状态数据。
			1.该属性可以禁止第三方的Cookie发送；
			2.在HTTP响应头中，通过set-cookie字段设置cookie，可以带上SameSite选项；
			3.SameSite有三个值：
				1.Strict：完全禁止第三方
				2.Lax:相对宽松，第三方链接打开，第三方站点提交Cookie能携带Cookie，但是第三方Post，img，iframe都不会携带；
				3.None：完全不会禁止，任何情况都可以携带Cookie
		2.服务端验证请求的来源站点：判断是否第三方
			1.HTTP请求头中有Referer和Origin属性
			2.Referer记录HTTP请求的来源地址，但是有些时候暴露URL给服务器并不合适，所以选择不上传Referer；
			3.Origin属性：在XHR，Fecth发起请求，都会带上Origin（不含有路径信息）属性；
		3.CSEF Token
			除了上面两种，还可采用Token验证
			1.首先，在浏览器向服务器发起请求时，服务器生成一个CSRF Token（服务器生成的字符串），然后将字符串植入页面并返回；
			2.第二步，进行权限操作的时候就带上这个Token，然后验证Token是否合法；
			3.如何使第三方，那肯定是没有Token的，因为Token在页面中，必须要打开页面；
```

### 11.cookie 有哪些值

```
1.value：保存的值，字符串形式
2.domain：哪些域名可以使用
3.path：域名下哪些路径可以使用，一般都是/
4.expires/max-Age：到期时间
5.size：大小
6.httpOnly：让该cookie只允许在HTTP请求中携带，不能通过第三方
7.sameSite：通过严格，宽松，none模式限制cookie的携带。
```

### 12.图片懒加载和预加载

```
懒加载：延迟加载
	目的：优化服务端，减少请求次数。
	1.指的是在一个长网页中，用户达到该显示区域再去服务器请求数据加载。
	2.这样做的好处，提升网站首屏加载速度，提升用户体验，减少服务器压力。
	3.购物商场的商品图片，将图片真实路径保存起来，监听滚动事件，等到触发时，将路径赋值给图片的src属性。

预加载：提前加载。
	1.提前将所需要资源请求到本地，这样后面在需要用到时就直接从缓存中获取资源
	2.预加载减少用户等待时间，提升用户体验。
	3.方式：
		js中的image对象，为image对象设置src属性，实现预加载

```

### 13.如果页面上图片很多，怎么优化

```

```

### 14.多个页面之间通信

```
1.通过URL传递：
	"http://localhost:3000/b.html?data=" + data
	可能会导致url过长
2.localStorage
	本地存储，同源策略，整个源的页面也可以访问到
3.postMessage向指定窗口发送信息，监听窗口上的message信息；
```

### 15.spa 应用的优缺点

```
优点：
	1.用户体验好，快，内容改变不需要重新加载整个页面，避免不必要的渲染；
	2.对服务器压力小

缺点：
	1.不利于SEO优化
	2.第一次加载时需要加载所有内容，会更耗时间

```

### 16.为什么CSS动画比JS动画高效

```
1.显示器如何显示动画？
	1.每个显示器都有刷新频率，通常60HZ，每秒更新60张图片
	2.更新的图片都来自于显卡中一个叫前缓冲区的地方
	3.显示器做的任务很简单：每秒从缓冲区读取前60张图片显示出来就行
2.显卡做啥？
	1.显卡职责是负责合成新的图像，并把图像保存到后缓冲区，一旦写入后缓冲区，系统会让新旧缓冲区互换
	2.互换后显示器可以读取到最新的图像
	3.显卡的更新频率和显示器刷新频率一致
	4.但是某些场景下，显卡处理图片很慢，就会导致视觉卡顿
3.帧和帧率
	1.一幅图像就是1帧
	2.帧率就是每秒钟更新多少图片，比如60张图片/s的帧率就是60帧=60hz=60fps
4.渲染流水线：
	1.CSSOM+DOM => 计算样式 => 布局树 => 分层=> 合成
	2.渲染路径越长，渲染花费的时间越久
	3.渲染的方式：
		1.重排：要让整个渲染流水线都走一次，重新布局了，花费时间最久
		2.重绘：不需要重新布局，但是需要重新计算绘制信息，比如颜色之类的，花费时间稍微短
		3.合成：无需触发布局和绘制，如果采用GPU，效率极高
	
5.分层/合成：
	1.分层是在生成布局树之后操作的
	2.渲染引擎会根据布局树的特性（动画样式）生成分层树
	3.层树是渲染流水线末端的操作了，有了分层树，然后根据分层树去生成绘制指令的列表（Paint BackGroundColor:Black）
	4.有了绘制指令之后就光栅化了，也就是按照绘制指令去生成图片
	5.绘制完成之后，就放到显卡的后缓冲区了
	6.特别注意的点，合成操作是在合成线程里面操作，不会影响到主线程，这样可以提高绘制效率
6.分块
	1.页面内容是有可能大于屏幕的，如果等所有图层都生成完毕再去合成（绘制图片）的话，浪费性能
	2.合成线程会将图层分为大小固定的图块，优先绘制当前视口的部分，可以大大提升页面加载速度
7.总结
	1.上面的分层合成去完成动画，有单独的合成线程处理不影响主线程，而且还会分块优先绘制当前视口的内容，效率++；
	2.用js去操作的话，整个渲染流水线都得走一遍，而且影响主线程，效率底下
	3.可以使用will-change告诉渲染引擎，这里可能会做动画，浏览器的合成线程会为该元素单独绘制一帧，不影响主线程，效率++
```



## 五、操作系统

### 1.进程与线程

```
概念：
  进程：
    1.是资源分配的基本单位，一个进程就是一个程序;
    2.启动一个程序，操作系统为改程序新建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这个环境叫进程
  线程：
  	1.是程序执行最小单位
  	2.线程不能单独存在，由进程启动和管理

区别：
	1.多进程是资源分配的最小单位，	线程是程序执行的最小单位
	2.进程有自己独立的地址空间，		 线程是共享进程的数据的，使用相同的地址空间
	3.进程开销大						线程开销小
	4.进程之间互相隔离，一个进程挂起不会影响其他进程的运行		一个进程中的任一线程崩溃，会导致整个进程崩溃
	5.一个进程关闭之后，操作系统会回收进程所占用的内存

1.进程通信：
	1.匿名管道
	2.具名管道
	3.消息队列
	4.共享内存
```

### 2.协程

```
协程是一种比线程更加轻量级的存在。
可以把协程看成是跑在线程上任务，一个线程上可以存在多个协程，但是只能同时执行一个协程。
注意：协程不被操作系统内核管理，完全由程序控制。这样的好处是提高性能，不会像切换线程样消耗资源。
例子：当前执行A协程，要启动B协程，那么A协程需要将主线程的控制权交给B协程。则A是B的父协程。
作用：将函数暂定执行/恢复执行
```

### 3.单进程

```
1.浏览器所有功能模块都在一个进程里面，如网络线程、页面线程。这种模式容易导致 不稳定、不流畅、不安全问题
2.不稳定：其中一个线程崩溃了，导致整个浏览器崩溃，其他tab页面也是，插件是最容易崩溃的
3.不流畅：同一个时间只能执行一个模块，JS、渲染、网络、插件等，脚本和插件都很容易让浏览器变的卡顿
4.不安全：通过插件可以获取到系统资源，页面运行插件，意味着可以操作你的电脑
```

### 4.目前浏览器的多进程

```
1.Chrome包括：浏览器主进程*1、网络进程*1、GPU进程*1，渲染进程*n、插件进程*n

浏览器进程：
	负责用户界面显示、用户操作，管理子进程、存储功能
渲染进程：
	1.核心任务将JS、HTML、CSS转换成用户可以交互的页面，排版引擎和JS引擎都是在该进程下运行
	2.Chrome为每一个tab标签创建一个渲染进程
	3.渲染进程运行在沙箱模式下
GPU进程：
	1.一开始是为了实现CSS 3D效果，后来网页的绘制都用GPU
网络进程：
	1.负责网络资源的加载，之前是在浏览器进程的模块，最近的版本独立出来了
插件进程：
	1.插件是最容易崩溃的，有了插件进程去隔离，页面稳定性得到提高
	2.一个插件的崩溃不会导致整个浏览器的崩溃

总结：
	1.多进程解决了稳定性、流畅性、安全性
	2.导致更高资源的占用，因为每个进程都包含一些公共基础结构的副本，如JS运行环境，导致消耗一些重复的内存资源
	3.更复杂的体系结构，各个模块之前耦合性高、扩展性差
```

## 四、GIT

### 1.git 撤销/回滚

```
1.撤销：在本地进行的相关操作，但是并没有提交到远程仓库；
	1.修改，但是未进行add
		1.git checkout fileName
	2.多个地方进行add，但是只想提交一部分
		1.$git reset HEAD <filename>
	3.已经commit但是未提交
		$ git commit --amend -m"说明"

2.回滚：已经提交到远程仓库
	1.删除最后一次提交
		1.先git revert HEAD 再git push origin master
		2.先git reset --hard HEAD^再git push origin master -f、
		两者区别：revert是放弃某次提交，生成新提交，有记录
				 reset是将HEAD指针指向未提交，没有记录
```

#### . git pull 和 git fetch 的区别

```
git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。

git pull 会将远程仓库的变化下载下来，并和当前分支合并。
```

#### 3. git rebase 和 git merge 的区别

```
git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。

git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会
保留之前每个分支的 commit 历史。

git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后
将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记
录了。

1.git merge
优点：
1. 保留了完整的提交历史。
2.易于理解项目的历史变化。
缺点：
1.可能会导致历史记录变得复杂，尤其是在大型项目中。
2.在解决冲突时，可能需要更多的手动干预。
2.git rebase
优点：
1.生成一个更简洁、线性的历史记录。
2.在解决冲突时，可以更容易地识别和合并更改。
缺点：
1.改变了提交历史，可能导致与其他分支的冲突。
2.不适用于公共分支，因为更改可能会影响其他人的工作。

```
