## 一、计算机网络

### 1.http与https区别

```\
http相当于在网络上裸奔，https就是穿了衣服。

http在传输数据的时候是明文的		https传输数据是经过SSL加密的
安全性低						  安全性高
不需要ca证书，成本低				  需要ca证书，需要一定的费用
80端口						   443端口
http无状态连接
```

### 2.七层/四层/五层协议

![七层协议](D:\Note\笔记图片\七层协议.png)

- 应用层： DNS/HTTP/FTP/SMTP 
- 运输层：TCP/UDP

### 3.输入url到实现页面的过程

1. DNS解析，把域名解析成IP地址
2. 客户端和服务端建立连接
3. 客户端发起HTTP请求
4. 服务器处理请求并返回数据
5. 浏览器接收数据并解析
6. 断开连接

### 4.base64和url的区别

```
标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式.
```

### 5.base64

```
特点：
	1.便于网络传输
	2.不可见性
区分：
	1.base64是编码(encodeing) 而不是加密(encryption)
应用
	1.图片存储是2进制的，而不是文本形式，要传输他的话，要将2进制转为文本形式，这个时候就可以用base64
```

### 4.HTTP状态码及其含义

- `1xx`:状态信息码
  - `100 continue` 继续
- `2xx`: 成功状态码(表示正常处理)
  - 200 OK
  - 201 请求成功并且创建了服务器资源
  - 202 服务器接受请求，但并未处理
  - 204 `No Content`成功但没有数据返回
- `3xx`重定向
  - `301 Moved Permanently` 永久重定向
  - `302 Found` 临时重定向
  - `304 Not Modified` 资源找到，但未符合条件
- `4xx` 客户端错误
  - `400 Bad Request` 服务器无理解请求的格式，不要再次发起请求
  - `401 Unauthorized` 未授权(未登录，无token...)
  - `403` 禁止访问
  - `404` 找不到与URI匹配的资源
- `5xx` 服务器错误
  - `500 Internal Server Error` 最常见的错误
  - `503  Service Unavailable ` 服务器暂时无法处理请求

### 5.HTTPS加密过程

```
原理->过程

1.客户端向服务器发起HTTPS请求
2.服务器创建公钥私钥，将包含公钥的数字证书发送给客户端
3.客户端对证书进行验证，验证通过后公钥将密钥进行加密
4.客户端将加密过后的密钥发送给服务器
5.服务器用自己的私钥对密钥进行解密
6.之后就通过对称性加密的方式进行加密通信
```

### 6.HTTP缓存

```
强缓存：
	HTTPCache-Control首部和Expries首部，给每个文档添加一个过时日期，浏览器再次发起请求的时候，就会以当前时间和过期时间进行比对，没过期，命中，过期，就去服务器请求新鲜的数据.
	Cache-Control: max-age:可以设置最大使用事件，
	Expires:设置一个过期的日期，但是修改客户端的事件可以影响命中缓存，优先用cache
	
协商缓存：
	资源到期了，并不意味资源发生改变，没改变就无需再次发起请求。客户端和服务端可以通过某种验证机制去判断当前请求是否可以使用缓存。所以第一次请求的时候浏览器就会把响应头部的缓存标识保存起来。再次请求就会带上这个头部。服务器验证可用，就是304，不可用就是200
	
	Last-modified/If-Modified-Since：Last-modified服务端资源最后修改时间，由服务器响应给浏览器，浏览器将它保存为If-Modified-Since。再次发起请求就会比对这两个，一样就表示没修改过，返回304。不一样就是修改过了。返回200。
	
	Etag/If-None-Match：Etag是服务器生成的hash字符串，表示文件唯一标识符，在请求时由服务器发送给浏览器，浏览器保存为If-None-Match，再次发起请求时，会进行对比，一样就304，不一样200了
	
	区别：
		Etag精确度比Last-Modified高，因为修改时间变了，但是你内容没变，所以Etag更好
```

### 7.DNS运行过程，DNS性能优化的方法？

- **DNS作用**

- 把域名解析成相应的ip地址

- **DNS过程**

- 1.**递归查询**

  - ![1584711632672](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1584711632672.png)
  - 1.输入 **域名**后，**客户端**向**本地DNS服务器**要该域名的**IP地址**。
  - 2.**本地DNS服务器**没有，本地DNS服务器找**根域名服务器**要.
  - 3.根域名服务器没有，根服务器找A顶级域名服务器要，逐级向下找
  - 4.找到后把该域名逐级返回到**客户端**，并保存到缓存，以备下一次使用

- 2.**迭代查询**

  - ![1584712482251](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1584712482251.png)
  - 全是客户端进行询问

- **总结**

  - 输入域名:arrow_right:操作系统检查本地host文件是否有映射关系 false？ :arrow_right: 客户端向本地DNS发起查询 :arrow_right: 采用递归查询或者迭代查询.

- **DNS优化**

  - 减少`DNS`请求数量

    - DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表等的主机名，减少不同的主机名就可以减少DNS查找

  - 缩短`DNS`请求时间

    - 预加载

      - `DNS  Prefetch`让具有此属性的域名不需要用户点击链接就可以在后台解析，则域名解析和内容载入是串行的网络操作，减少等待时间.

      - ~~~html
        <link rel="dns-prefetch" href="//atanx.alicdn.com">
        ~~~

### 8.HTTP0.9/1.0/1.1/2.0

```
1.HTTP0.9:
	就是请求+响应的模式，tcp三次握手连接+四次挥手断开连接
	
2.HTTP1.0
	1.在HTTP1.0里面就可以展示多种文件类型，js，css，图片，视频，声音；
	2.在HTTP1.0里面可以设置请求头，响应头可以满足多种类型的数据传输
	3.accept：text/html accept-encoding：gzip， accept-Charset: ISO-8859-1,utf-8
	4.但是每一次请求数据都得进行一次连接和断开连接，消耗性能
	5.缓存机制，状态码，用户代理（客户端基础信息）

3.HTTP1.1
	1.持久化连接（默认开启）：多次请求数据则不需要断开连接；连接一次可以进行多次请求响应；
	2.缺点：队头阻塞：只能上一次请求响应完成才会进行下一次请求；那么就有可能阻塞后面的请求
	3.引入Cookie：
	4.问题：对带宽的利用率低（tcp启动慢，开启多条tcp连接，队头阻塞）

4.HTTP2.0
	0.原因：tcp会竞争带宽，队头阻塞
	1.多路复用解决TCP竞争：就是一个域名只是用一个tcp长连接去传输数据，这样就不会竞争
	2.解决队头阻塞：正在执行的请求卡住就阻塞后面的，所以事先了资源并行请求，不按照顺讯返回，谁好了谁返回
	
	3.头部压缩：对响应头请求头进行了压缩，虽然单个头部不大，但是在大项目里面有几百个资源，如果把它们压缩到原来的20%，那也能提高很多性能
	
	4.设置请求的优先级，有些比较重要希望可以先对他进行请求
```

### 9.tcp和udp的区别

```
1.TCP 面向连接的			UDP是无连接的
2.TCP安全性高			 UDP安全性低
3.效率低				  效率高
4.TCP具有数据包排序机制，把乱序的数据包还原成完整的文件	大文件被拆分成小数据包传输，UDP是不知道如何组装，就无法还原成完整文件
5.TCP数据包丢失提供重新传机制  UDP数据包传输的过程中会丢失，不会重新传
```

### 10.知道哪些content-type

```
1.text/plain		文本类型
2.text/css			css类型
3.text/html			html类型
4.application/json json类型
5.application/JavaScript js类型
```

### 11.HTTP报文结构，有哪些header

```
请求报文结构：
	1.请求行：请求方法（Method） + 空格 + 统一资源标识符（URI） + 空格 + HTTP版本 + CR LF 
	2.请求头：字段名 + 冒号 + 值 + CR LF 
	3.空行： 回车符（CR）+ 换行符（LF
	4.请求体： 由用户自定义添加，如post的body等；
	
响应报文结构：
	1.状态行：HTTP版本 + 空格 + 状态码 + 空格 + 状态码描述 + CR LF ；
	2.响应头：字段名 + 冒号 + 值 + CR LF ；
	3.空行： 回车符（CR）+ 换行符（LF） ；
	4.响应体： 由用户自定义添加，如post的body等；
```

### 12.HTTP请求流程

```
1.构建请求行，请求方法/请求URI/HTTP版本
2.在本地查找缓存，有就拦截请求，返回该资源副本，减少服务器压力
3.准备IP和端口：
	1.通过DNS解析域名，得到IP
	2.解析URL有无端口号，没有默认80
4.等待TCP队列
	1.一个域名6个连接，10个TCP请求的话，4个需要排队，少于6，则进入连接
5.建立连接
	三次握手
6.发送HTTP请求
	建立连接之后，浏览器就可以和服务器通信
                              
```

### 13.HTTP响应流程   

```
1.返回请求
 处理好请求返回数据给浏览器
2.关闭连接
 	一般情况下，直接关闭连接即可，但是如或有connection:keepAlive，就保持长连接，节省下一次的连接时间
3.重定向
```



### 14.第二次打开网页保持登陆状态

```
1.使用了setCookie字段
2.第一次登陆成功，后端生成用户身份的字符串，保存响应头setCookie中，返回给前端。
3.浏览器解析响应头，遇到setCookie，保存在本地。
4.再次访问时，就会读取本地setCookie信息，并且在请求头把它带上发送给服务器
5。服务器验证，通过后把该用户的信息发送给浏览器
```

### 15.计算机网络模型

### 10.503

## 二、HTML

### 1.H5标签

```
header/footer/article/nav/section/video/audio/canvas
```

### 2.get和post

```
浏览器：
	get用于请求资源		post用于提交表单
	get参数url可见		 post参数不可见
	get请求可以缓存		post请求不可以缓存
	get数据一般2-4k		 post请求传输数据大小php.inis设定
	
```

### 3.post数据类型

```
1.application/x-www-form-urlencoded(最常见)
	原生表单，不设置enctype，就用这种方式
	
2.multipart/form-data(常用)
	必须让表单的enctype等于multipart/form-data
	
3. application/json

4.text/xml
```

### 4.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

- 行内元素有：`a b span img input select strong`
- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`
- 空元素： ` <br> <hr> <img> <input> <link> <meta> ` 
- 行内元素不可以设置宽高，不独占一行
- 块级元素可以设置宽高，独占一行 

### 5. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

- `!DOCTYPE html`位于文档的最前面，告诉浏览器的解析器用什么规范去解析这个文档

### 6.操作节点(Node)的方法

```
1.appendChild		添加节点
2.removeChild		删除节点
3.replaceChild		替换几点		返回被替换节点
4.hasChildNodes		是否有子节点	   返回布尔值
```

### 7.DOMContentLoaded和load区别

```
DOMContentLoaded：
	当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完全加载。
load:
	整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。
```

### 8.HTML5新特性

```
1.语义化标签
	header，footer，article，nav，audio，video
2.2D/3D:
	canvas，svg
3.多媒体
	audio、video
4.离线存储
	localStorage，sessionStorage，indexDB
```



## 三、浏览器

### 1.跨域

```
1.jsonp
	利用浏览器没有跨域限制的漏送，通过script指向要访问的地址，
	并提供一个回调函数去接收通讯时接收的数据。
	但是只限用于get请求
	
2.cors
	这个需要前后端同时支持，前端会自动实现，关键在于后端，服务端
	设置：
		Access-Control-Allow-Origin 就可以开启CORS
		Access-Control-Allow-Headers
		Access-Control-Allow-Methods 哪些方法
	
3.document.domain
	该方式只能用于二级域名相同的情况下，如：a.test.com与b.test.com
	只要给页面添加document.domain='根域名'
```

### 2.浏览器缓存机制

### 3.如何进行网站的性能优化

```
1.请求HTML数据和构建DOM中间有空闲时间，是瓶颈
```



**三件套+server+图片**

- `content`方面
  - 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名
  - 减少`DOM`元素数量
  - 使用iconfont
  - 删除不必要的元素
- `Server`方面
  - 使用`CDN`
  - 配置`ETag`
  - 对组件使用`Gzip`压缩
- `css`方面
  - 将样式表放到页面顶部
  - 不使用`CSS`表达式
  - 使用`link`，不使用`@import`
  - 避免使用表格
- `Javascript`方面
  - 将脚本放到页面底部 （自上而下的，先优先加载内容和样式，再去解析脚本）
  - 将`javascript`和`css`从外部引入
  - 压缩`javascript`和`css`
  - 删除不需要的脚本
  - 减少`DOM`访问 (重排、重绘，消耗CPU)
- 图片方面
  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化`css`精灵
  - 不要在`HTML`中拉伸图片

### 4.浏览器渲染UI

```
1.浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree

2.与此同时，进行CSS解析，生成Style Rules

3.接着将DOM Tree与Style Rules合成为 Render Tree

4.接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标

5.随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来

```

### 5.cookie和localSrorage、session、indexDB 的区别

|     特性     |                         cookie                         | session            |       localStorage       | sessionStorage |
| :----------: | :----------------------------------------------------: | ------------------ | :----------------------: | :------------: |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间，或者关闭窗口就消失 | 关闭生命周期就到期 | 除非被清理，否则一直存在 | 页面关闭就清理 |
| 数据存储大小 |                           4K                           | 4k                 |            5M            |       5M       |
| 与服务端通信 |             存放于浏览器，请求的时候会携带             | 存放于服务器       |          不参与          |     不参与     |
|    安全性    |                         不安全                         | 安全               |                          |                |
|     形式     |                         字符串                         | 对象               |                          |                |
|     应用     |                      登录、购物车                      | 登录、购物车       |                          |                |
|     跨域     |                        支持跨域                        | 不支持跨域         |                          |                |

### 6.Chrome优点

```
1.具有预解析操作：
	之前如果文件中出现js、css外部文件时，需要下载，就会耗费时间，从而导致DOM阻塞。
	现在会启动预解析线程，分析HTML文件有无外部引入文件，从而提前下载
```

### 7.阻塞渲染问题

```
1.css解析成CSSOM，html解析生成DOM，生成渲染树。
2.JavaScript阻塞DOM生成：
	1.因为JavaScript要操作DOM
	2.可以使用defer(contentLoaded事件前)和async(加载完立马执行)去优化，使js文件异步加载
3.css阻塞js执行，但是不阻塞js加载：
	1.因为js要操作css，需要依赖样式表
	2.所以css也有可能会阻塞dom生成
	3.前提是样式表放在前面，在后面的话，css解析就不会并行了
```

### 8.如何生成DOM

```
1.渲染引擎内部，有HTML解析器。解析过程是一边加载一遍解析的。
2.content-type判断文件类型，创建一个渲染进程，网络进程和渲染进程会有一盒共享数据的管道。
3.网络进程输送数据，渲染进程中的HTML解析器读取数据
4.解析过程三个阶段：
	1.通过分词器将字节流转换为Token，分别是StartTag 文本Token EndTag 三个Token，放入栈中
	2.Token解析成DOM节点，DOM节点添加到DOM树中。HTML解析器有一个Token栈结构,用于解析父子关系，前面生成的Token压到这个栈中。
	3.压到栈中的是StartTag，解析器为该Token创建一个DOM节点，父节点就是栈中左边的元素。
	4.遇到的是 文本Token，生成文本节点，将该节点直接添加到DOM树种，无需压栈，父节点就是栈顶元素
	5.分词器解析出来的是EndTag，就和栈顶元素对比，比如 startTag div 和 EndTag div 匹配成功，则该div元素解析完成
这样，分词器不断压栈出栈，整个解析过程一直这样解析下去，直到分词器将所有字节流分词器完成。
	
```

### 9.减少白屏时间

```
白屏原因：
1.页面是需要布局树渲染的，那么JS，和CSS都会阻塞dom解析，所以会影响布局树的生成。

解决办法：
	1.通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件 之后就可以直接开始渲染流程了。
  2.但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等 工具移除一些不必要的注释，并压缩 JavaScript 文件。
  3.还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
  4.对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这 样只有在特定的场景下才会加载特定的 CSS 文件。
```



## 五、操作系统

### 1.进程与线程

```
进程是资源分配的基本单位，一个进程就是一个程序，
线程是程序执行最小单位

区别：
	1.多进程是资源分配导的最小单位，	线程是程序执行的最小单位
	2.进程有自己独立的地址空间，		 线程是共享进程的数据的，使用相同的地址空间
	3.进程开销大						线程开销小
```



## 四、GIT

### 1.git 撤销/回滚

```
1.撤销：在本地进行的相关操作，但是并没有提交到远程仓库；
	1.修改，但是未进行add
		1.git checkout fileName 
	2.多个地方进行add，但是只想提交一部分
		1.$ git reset HEAD <filename>
	3.已经commit但是未提交
		$ git commit --amend -m"说明"

2.回滚：已经提交到远程仓库
	1.删除最后一次提交
		1.先git revert HEAD 再git push origin master
		2.先git reset --hard HEAD^再git push origin master -f、
		两者区别：revert是放弃某次提交，生成新提交，有记录
				 reset是将HEAD指针指向未提交，没有记录
```

