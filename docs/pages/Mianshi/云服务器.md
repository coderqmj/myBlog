## 一、项目介绍

```
腾讯云服务器购买页/控制台
	云服务器购买页是提供给用户选择并创建自定义配置机型的页面，包括地域/可用区/机器类型/镜像等的选择。云服务器控制台是提供给用户查看/续费/扩容/开关机/退还等操作的页面。关键成果：通过支持国际站包年包月/机型对比工具/订单催收等功能，帮助公司增长营收
	1.技术栈：React，Redux-Saga，Typescript，TeaDesign，Hooks
	2.项目性能优化：通过技术手段将js资源从3.64MB优化到2.5MB，优化接口请求方式/顺序等手段提升加载速度。
	3.公私有云一体化融合：设计了一套方案帮助公司完成前端公私有云一体化的目标，提升效率。
	4.收入增长：负责的项目（本地专用集群CDC）经过21-23年的建设，从22年300w收入增长到23年4000w收入
	5.技术分享：开发过程中遇到的问题会思考通用解决方案并输出相关资料在周会上分享，如时间，折扣，价格计算，翻译流程等会遇到的问题
	6.数据收集：使用公司数据上报工具收集购买页相关数据，如购买方式，新功能使用情况，转化率等
	7.支持国际化：参与多个项目新上线国际站，使用i18next支持了多种语言，并且参与了制定翻译流程规则，规范了国际站开发与发布
	8.用户体验：参与降工单专项和收集用户反馈，云服务器路由到前端的工单数量由22年的每周5起，到现在每周1起，提升了用户体验
```

## 二、详细

### 1.公私一体化方案

```
问题难点：
	1.怎么优雅的将这些差异化特性处理好，而不是直接使用大量的if去判断，会导致代码难以阅读和维护。
	2.因为我们云服务器用户很多，而且用户经常会来问一些逻辑处理相关的事情，比如选了某个机型怎么不支持云盘啊，怎么不支持加密功能啊，所以不可能只让某一个负责人，所以采用轮流值班模式，所以我的想法是设计一个对于不经常开发这项目的人也能快速看到这里差异化的逻辑。
	3.然后这个一体化不是一个产品在做，是我们20来个产品都要做改造，所以能不能设计一个方案，所有产品都能适用，并且要修改的代码尽可能少?尽可能将公共逻辑抽离到一个工具里面去做处理，而不需要再每一个项目中单独处理冗余操作
	
1.公司为了节省人力和提高效率，提出了公私一体化技术专项。
2.公私一体化是要把公有云和私有云的代码都维护在一套里面，但是页面是分开部署到不同站点。
3.开发都是由公有云的人来开发，部署则由私有云的人拉公有云代码部署
4.公私有云区别：
	1.私有云有的能力公有云都有，但是私有云的提供的能力会少于公有云，比如不支持退还机器，并且只有一种计费模式
	2.公有云的请求方式底层调用和私有云底层调用是不一样的，但是参数是一样的。所以要根据环境去判断当前的环境
5.当时想着肯定不能用if else到各个业务里面判断当前是否为TCE环境，因为这样一堆判断的代码难以阅读维护，出了bug难以定位和修复
6.然后就想着写一个配置文件，通过模块去划分公有云和私有云分别支持哪些特性，搞了一个特性开关。再去业务代码里面判断是否支持该特性
	1.这样能通过配置文件一眼看清哪些特性有差异
	2.第二个就是简化了代码，不管是阅读性和可维护性都上升了一个档次。
	3.最后还意识到一个问题：就是如果新增了一个开关，在私有云那里设置了是false，但是有的开发者可能会忘记在公有云配置添加，那公有云取用的时候会config.xxx = undefined，也是false，那就有问题，所以为了限制这个行为，在定义配置的时候，加上了统一的类型限制。这样就能确保两个文件开关数量都是统一
7.其实最耗时最麻烦的是，由前端找出私有云不支持的API
	1.前端要走查每个功能对应的API接口是否支持，参数是否统一等等，然后我这里搞了个表格去统计每个功能的走查情况，未通过/部分通过/全部通过，都将该功能实用对应的颜色标记起来，然后拉会确认是否需要支持，以及能支持联调的大概时间。
	
8.上线后发现包体积有点大: stat:500kb parsed: 228kb gizp:72.5kb，优化后：stat: 35kb parsed: 29.52kb，gzip：9.91
	1.精简包体积，移除jquery,moment,i18next
	
9.uniform-request
  1.最关键的功能是请求分发，根据当前环境判断分发给私有云还是公有云
  	1.如果是私有云，则需要用他们的挂载在window.sdk.yApiRequest去请求
  	2.如果是公有云，那就要使用原本的请求方式
  	3.再次基础上，增加了许多其他优化
  2.想了下，这种固定写死的默认请求方式也有问题，因为当前共有云请求方式还有其他方式，那肯定要支持自定义才行，而且tce部分也不能保证没有多种请求方式
  	1.然后又设计了支持自定义请求方式的方法，需要在业务侧自行调用init，将请求方式做替换
	3.有些查询请求比如可用区列表，地域列表等是可以使用memorize缓存相同参数的Promise，也做了这个支持，在request的options参数里面设置了withMemorizeCache，去做查询缓存
	2.设置带过期时间的localStorage，地域信息，不经常更新，但是又希望定时拉取
	3.在融合过程中发现每个项目都有高度相似的工作
		1.比如10多个项目都各自封装一些地域获取地域接口，格式化地域的方法，地域id转地域名等很多方法，同时，每个项目都要调用初始化地域信息并保存在本地缓存中的操作。
		2.这种高度重复的文件，不仅难以维护，而且大大提升了文件重复率，如果新增或者改动其中的方法，那就要去每个项目都操作一遍，效率低下，所以统一请求npm包中，把这些地域相关的方法，请求，都统一封装进npm包中，并且对其做一些初始化工作
```

### 2.相同参数缓存promise

```
1.参数作为key，函数的执行结果（promise）作为value
2.第一次执行的时候，func.cache是空的，func.cache[key]也是undefined，但是func.cache[key] = func.apply(this, args);给函数加上了缓存
3.当二次的时候，就可以直接判断当前key是否有缓存，有的话，直接取出来用

```



### 2.性能优化

```
JS资源大小优化：
优化前：3.64M src为1.9MB+npm 1.7MB
1.很多地方没有按需加载，能否有工具统一做成按需加载？或者打包的时候自动处理？
	1.tea当前是有处理，tea build 
2.remoteConfig精简化，一个配置文件，记录了地域和可用区等的配置信息，比如展示Icon（新地域or特惠地域），还有各个机型的配置
	1.由于地域+可用区+机型的配置达到上万行，而且只是一种语言，构建的时候把34种语言都打进去了，达到了700kb+
	2.历史原因，做迁移之前本来是一个远程文件，根据语言去请求对应的语言版本，现在使用本地文件配置，导致构建的体积变大
	3.由于大部分配置都由接口支持了，比如机型的相关，磁盘信息。不需要本地配置，所以可以精简
	如何精简：
		1.不相关的字段删除，比如whiteListKey，cvmType等等
		2.只导出一份配置文件，
		3.删除接口已经支持的配置
	4.结果：600kb => 30kb
3.只用到了lodash种的isEqual，但是引入了70kb的资源，使用es-toolkit去替换，构建体积小了90%，而且性能更好
	1.按需引入es-toolkit里面的方法，70kb直接变成2kb
	2.即使是按需加载，也会很大
	3.按需引入：import { debounce } from 'lodash-es'
4.计费平台sdk npm包，20kb左右，但是可以使用平台提供的app包里面的sdk去异步加载该方法，可以减少一个npm包的安装
const billingSdk = await sdk.use('billing-sdk');
billingSdk.directToCheck()
5.redux-logger导入了，但是只有在product的情况下才使用，dev和pro模式下都加载并导入了，也就会打包进去
	1.如何解决：我们可以使用配置文件+NormalModuleReplacementPluginwebpack插件对开发模式和生产模式做替换
	2.写了一份配置文件，分别是dev.config.ts和pro.config.ts，dev模式下才导出日志中间件，pro模式下不导出
	3.这样执行webpack的时候判断是dev模式的时候，把默认的配置替换成dev的配置即可
	4.这样的话，生产环境走默认配置读取不到中间件，运行环境读取到这个文件，里面加载了中间件就会被打包进去
6.@tencent/cvm-uniform-request，包有200kb，需要优化
	1.去除moment.js，在里面做了一些地域信息的缓存，同时也设置了过期时限，所以需要对比时间是否到期，用momentjs，最后用
		 1.new Date() < new Date(cacheItem.expiredTime) 去判断当前缓存是否到期。
		 2.new Date(new Date().getTime() + 1 * 24 * 60 * 60 * 1000) 设置过期时间
	2.去除i18nText的依赖，因为我们云API的请求接口的地域参数是必选项，比如广州上海，不然的话，都请求不到后端，所以需要再前端拦截
		1.前端拦截的话就需要给出相应提示，所以提示文案就分为中英文，开始实现的时候就用i18next.init去初始化词条了。
		2.等到了上线之后，再去分析思考，其实并不需要借助i18next这个库，因为只有3个词条，所以我写一个映射表，返回对应的中英文即可
	3.这样的话就把包体积大小干到10kb了
	
7.和导入方式有关，导致tree shaking失效
	1.老版代码是导出一个util对象，里面包含各种各样方法，虽然有些方法没有用到，但也打包进去
	2.改为函数式，需要哪个导入哪个
8.使用了骨架屏
9.基于路由代码的拆分?
	1.lazy+Suspense懒加载
	2.拆分前：
	3.拆分后：所有加起来的总体积略大于拆分前的，但是性能会更好
10.将导出文件改造为纯模块，不要写有副作用的代码（window.xx = xx），因为tree-shaking的时候，将没有用到的模块给删除
```

### 2.1模块替换插件使用

```js
if (process.env.TEA_BUILD_TARGET || config.mode === 'development') {
      customPlugins.push(
        new NormalModuleReplacementPlugin(/src\/(.*)/, (resource) => {
          if (process.env.TEA_BUILD_TARGET && resource?.resource?.includes('/src/config/envConfig.ts')) {
            resource.resource = resource.resource.replace(
              '/config/envConfig.ts',
              `/config/${process.env.TEA_BUILD_TARGET}.envConfig.ts`,
            );
          }

          if (config.mode === 'development') {
            if (resource?.resource?.includes('/src/envConfig/envConfig.ts')) {
              resource.resource = resource.resource.replace('/envConfig/envConfig.ts', `/envConfig/dev.envConfig.ts`);
            }
          }
        }),
      );
    }
```





### 3.时间处理

```
 // cgi返回系统时间
    const { systemTime = new Date().getTime() } = common;
    // 系统时间和本地时间的差
    const systemClientTimeGap = systemTime - new Date().getTime();
    util.cookie.set('systemTimeGap', `${systemClientTimeGap}`);
    
然后写通用方法：

export const getSystemTime = function (...args) {
   var systemClientGap = comData.systemClientTimeGap || Number(util.cookie.get('systemTimeGap')) || 0;
   return new Date().getTime() + systemClientGap;
};
```

### 4.查看首屏加载速度

```
1.performance.getEntriesByType("paint")可以查看FP和FCP
```

### 5.国际化文案的原理

```
1.首先进行tea scan扫描本地词条情况，有多少已翻译，多少待翻译
2.然后使用tea dict push -l en 选择需要提交翻译任务的词条，就会创建对应的需求单
3.等翻译返回，就tea dict pull从远程仓库拉取词条
4.然后构建的时候选择需要的语言版本即可，比如英文，t('中文')构建出来的英文版本还是t('中文')
	1.只不过是内部帮我们找到这个英文映射
	
问题1：如何scan所有词条
	1.
```



## 二、难点亮点

### 2.1 公司有云一体化方案设计

```
1.主导整个方案的制定，以前是公有云团队维护公有云，私有云团队维护私有云。大老板升上去后同时管理着私有云团队和公有云团队，他就想两个团队资源做整合，节省人力。公有云和私有云都由公有云团队负责开发，但是私有云的部署由私有云那边自行部署。
2.问题和难点是什么呢?
	1.涉及改造的团队和项目很多，如果想要设计一个方案只解决当前项目改造很简单，但是我想要做的是一个通用的解决方案，能用于所有项目和所有团队。
	1.较多特性不一致情况，但总体来说公有云的功能大于且包含私有云的，难道是各种if else判断吗？拿着当前环境去判断然后去处理不同的逻辑？
	2.私有云它是在另外一个环境部署开发的，

```

## 三、收获是什么？

### 1.能单独设计一个新项目

```
1.这里的新项目指的不是一个和其他业务相似的项目，去仿造另外一个项目的设计，完全不思考就将另外其他项目的技术栈，文件组织方式等等照搬过来，而是思考我们要做的业务适用于哪些技术栈，哪种方式去实现我们的项目是高效的，就比如说我们的购买页，他是用于选择各种机型配置，光是配置项就达到好几十个，然后选择了前面的配置，又会影响后续配置的选择，所以它这种场景对数据监听需求是非常强的，所以我们选择了redux-saga去做监听，虽然说它redux-saga写起来比较麻烦，但是它优秀的监听机制确实用起来很爽。
2.再比如，我们机器管理系统或者运营端去使用redux-saga，那就完全没有必要了，那就是杀鸡用宰牛刀了，因为运营端或者管理系统这种不会涉及到太多复杂的场景，大多数都是查数据，改数据的操作，甚至redux都不用也能行。
3.因为写这种项目，技术含量技术含量低，且大量重复工作，所以我这里的理念是：
	1.能够高效快速开发
	2.上手成本低，不要用太复杂的东西，别人用起来还要学习成本
```

