## 一、项目介绍

```
腾讯云服务器购买页/控制台
	云服务器购买页是提供给用户选择并创建自定义配置机型的页面，包括地域/可用区/机器类型/镜像等的选择。云服务器控制台是提供给用户查看/续费/扩容/开关机/退还等操作的页面。关键成果：通过支持国际站包年包月/机型对比工具/订单催收等功能，帮助公司增长营收
	1.技术栈：React，Redux-Saga，Typescript，TeaDesign，Hooks
	2.项目性能优化：通过技术手段将js资源从3.64MB优化到2.5MB，优化接口请求方式/顺序等手段提升加载速度。
	3.公私有云一体化前合：设计了一套方案帮助公司完成前端公私有云一体化的目标，帮公司提升效率。
	4.技术分享：多次分享云服务器开发注意事项，如时间，折扣，价格计算等会遇到的问题，以及通用解决方案
```

## 二、详细

### 1.公私一体化方案

```
1.公司为了节省人力和提高效率，提出了公私一体化技术专项。
2.公私一体化是要把公有云和私有云的代码都维护在一套里面，但是页面是分开部署到不同站点。
3.开发都是由公有云的人来开发，部署则由私有云的人拉公有云代码部署
4.公私有云区别：
	1.私有云有的能力公有云都有，但是私有云的提供的能力会少于公有云，比如不支持退还机器，并且只有一种计费模式
	2.公有云的请求方式底层调用和私有云底层调用是不一样的，但是参数是一样的。所以要根据环境去判断当前的环境
5.当时想着肯定不能用if else到各个业务里面判断当前是否为TCE环境，因为这样一堆判断的代码难以阅读维护，出了bug难以定位和修复
6.然后就想着写一个配置文件，通过模块去划分公有云和私有云分别支持哪些特性，搞了一个特性开关。再去业务代码里面判断是否支持该特性
	1.这样能通过配置文件一眼看清哪些特性有差异
	2.第二个就是简化了代码，不管是阅读性和可维护性都上升了一个档次。
	3.最后还意识到一个问题：就是如果新增了一个开关，在私有云那里设置了是false，但是有的开发者可能会忘记在公有云配置添加，那公有云取用的时候会config.xxx = undefined，也是false，那就有问题，所以为了限制这个行为，在定义配置的时候，加上了统一的类型限制。这样就能确保两个文件开关数量都是统一
7.其实最耗时最麻烦的是，由前端找出私有云不支持的API
	1.前端要走查每个功能对应的API接口是否支持，参数是否统一等等，然后我这里搞了个表格去统计每个功能的走查情况，未通过/部分通过/全部通过，都将该功能实用对应的颜色标记起来，然后拉会确认是否需要支持，以及能支持联调的大概时间。
```

### 2.性能优化

```
JS资源大小优化：
优化前：3.64M src为1.9MB+npm 1.8MB
1.很多地方没有按需加载，能否有工具统一做成按需加载？或者打包的时候自动处理？
	1.tea当前是有处理，tea build 
2.remoteConfig精简化，一个配置文件，记录了地域和可用区等的配置信息，比如展示Icon（新地域or特惠地域），还有各个机型的配置
	1.由于地域+可用区+机型的配置达到上万行，而且只是一种语言，构建的时候把34种语言都打进去了，达到了700kb+
	2.历史原因，做迁移之前本来是一个远程文件，根据语言去请求对应的语言版本，现在使用本地文件配置，导致构建的体积变大
	3.由于大部分配置都由接口支持了，比如机型的相关，磁盘信息。不需要本地配置，所以可以精简
	如何精简：
		1.不相关的字段删除，比如whiteListKey，cvmType等等
		2.只导出一份配置文件，
		3.删除接口已经支持的配置
	4.结果：600kb => 30kb
3.只用到了lodash种的isEqual，但是引入了70kb的资源，使用es-toolkit去替换，构建体积小了90%，而且性能更好
	1.按需引入es-toolkit里面的方法，200kb直接变成10kb
4.计费平台sdk npm包，200k左右，但是可以使用平台提供的app包里面的sdk去异步加载该方法，可以减少一个npm包的安装
const billingSdk = await sdk.use('billing-sdk');
billingSdk.directToCheck()
5.redux-logger导入了，但是只有在product的情况下才使用，dev和pro模式下都加载并导入了，不知道是否有影响？
6.@tencent/cvm-uniform-request，包有200kb，需要优化
7.和导入方式有关，导致tree shaking失效
	1.老版代码是导出一个util对象，里面包含各种各样方法，虽然有些方法没有用到，但也打包进去
	2.改为函数式，需要哪个导入哪个
8.使用了骨架屏
9.基于路由代码的拆分?
	1.lazy+Suspense懒加载
	2.拆分前：
	3.拆分后：所有加起来的总体积略大于拆分前的，但是性能会更好
10.检查下项目中是否有devDependencies依赖装到dependencies里面了，导致体积变大
```

### 3.时间处理

```
 // cgi返回系统时间
    const { systemTime = new Date().getTime() } = common;
    // 系统时间和本地时间的差
    const systemClientTimeGap = systemTime - new Date().getTime();
    util.cookie.set('systemTimeGap', `${systemClientTimeGap}`);
    
然后写通用方法：

export const getSystemTime = function (...args) {
   var systemClientGap = comData.systemClientTimeGap || Number(util.cookie.get('systemTimeGap')) || 0;
   return new Date().getTime() + systemClientGap;
};
```

### 4.查看首屏加载速度

```
1.performance.getEntriesByType("paint")可以查看FP和FCP
```

