##  一、浏览器内核

> 谷歌之前用的是webkit，后来又使用Blink，属于为webkit的一个分支，谷歌开发，用于谷歌浏览器。

#### 什么是浏览器内核？

```
事实上，浏览器内核指的是浏览器的排版引擎：
	排版引擎也叫浏览器引擎，页面渲染引擎，样板引擎。
```

#### 渲染流程就是那张图了

在html里面可以执行JS是因为每个浏览器都有JS引擎

#### JS引擎

- webkit的JS引擎，苹果公司开发
  - 两部分：webCore(HTML解析)+JSCore
- V8谷歌开发，很强大。

#### V8如何运行JS

- 源码100W行c++代码
- 主要原理：
  - 黑色的是模块。
  - 分别是解析器、解释器、

```
1.Parse将JS代码转换成AST(abstract syntax tree)抽象语法树.
2.Ignition将语法树解释成字节码（类似汇编代码），字节码再进一步转成汇编，再转机器码，交给cup执行
```

![v8原理](./nodeImgs/node_v8_1.png)

#### 为什么V8高效

```
1.因为js是一门解释型语言，转成字节码交给cpu执行过程较为复杂，效率较低，需要字节码转汇编再转机器。
2、v8对js执行过程做了优化：
	1.会收集信息（博客上的图），如参数类型。
	2.将这些代码通过另外一个模块TurboFan将字节码直接转换成优化好的机器码，下一次再运行类似函数时就直接走TurboFan模块。
3.收集到了足够的类型信息，将字节码直接转换成优化好的机器码。直接进行执行。之后在运行代码走这个过程效率变得更高。

缺点/问题：
	1.比如一个sum(num1, num2)函数，第一次传入的是数字，那么下次再转换成机器码的时候传入的参数也会被按照数字来处理。
	例子：sum('AA','bbb'),就会让两个字符串进行拼接。
解决(博客的图)：
	转换成机器码之后再多一笔操作，
	Deoptimization（反向优化）：
		在某些特殊的情况下，反向优化成字节码，再优化成机器码执行。
```

## 二、邂逅NODE

#### 2.1常见的node全局对象

- process对象：process提供了Node进程中相关的信息：

  - node中的运行环境，参数信息等；
  - 可以将环境变量读取到process的env中。

- console

- 定时器函数

  - ```js
    setTimeout(() => {
      console.log('setTimeout')
    }, 1000);
    
    setInterval(() => {
      console.log('setInterval')
    }, 1000);
    
    setImmediate(() => {
      console.log('setImmediate')
    })
    
    process.nextTick(()=> {
      console.log('process.nextTick')
    })
    // nextTick -> setImmediate -> setTimeout -> setInterval...
    ```

  - 

#### 2.2特殊的全局对象

> 这些全局对象实际上是模块中的变量，只是每个模块都有，看起来像全局变量。但是在命令行交互中不可以使用，比如，__ dirname, __filename, exports, module, require().



## 一、JavaScript模块化

### 1.1什么是模块化？

- 模块开发开发最终目的是将程序划分成一个个小的结构。
- 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响其他结构。
- 这个结构可以将自己希望暴露的变量，函数，对象等导出给其结构使用。
- 也可以导入另外结构的变量函数，对象等。

### 1.2没有模块化带来的问题

- 变量 全局污染

### 1.3模块化的规范

> 模块化有AMD，CMD，CommonJS等是定义用什么样的归案去写代码，统一规范。每个模块化都有两个核心功能，模块本身导出暴露的属性，模块又可以导入自己需要的属性。

#### CommonJS和Node

- CommonJS是一个规范，而node是CommonJS在服务端一个具有代表的实现。
- webpack（模块化打包工具）打包工具具备对CommonJS的支持和转换。

所以，node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：

- 在Node中每一个js都是单独的模块；
- 这个模块中包括CommonJS规范的核心：exports，module.exports, require;
- 我们可以使用这些变量来方便的进行模块化开发。

#### exports 和 require

在单独的模块里面定义了变量可以用`exports`导出，可以用`require`导入；

```js
// a.js
const name = 'qmj';
exports.name = name;

// b.js
const obj = require('./a.js');
console.log(obj.name) // qmj
```

#### module.exports

- 既然可以用exports直接导出，为什么常用的是module.exports。
  - exports和module.exports的区别？
    - 在内部做的事情是 module.exports = exports;
    - 如果自己module.exports = {}那么就可以断开引用了
- 通过查询维基百科CommonJS规范的解析：
  - CommonJS中是没有module.exports的概念的；
  - 但是为了实现模块的导出，Node中使用的是Module（一个js文件就是一个module实例）的类，每一个模块都是Module的实例，就是module。
  - 所以在node中真正用于导出的其实根本不是exports，而是module.exports;
  - 因为module才是导出的真正实现者。

```
// a.js
const name = 'qmj';
module.exports = {
	name: name;
};

// b.js
const obj = require('./a.js');
console.log(obj.name) // qmj
```

## 三、常见内置模块

### 1.路径的模块——path

> 在不同操作系统中路径的形式有可能是不一样的，有的是// 有的是\ 那么一套代码就不可以在不同操作系统中使用了。那么调用path模块可以解决这个问题。

```js
const path = require('path');
const basePath = '/User/qmj';
const fileName = 'abc.txt';

const filepath = path.resolve(basePath, fileName)

```

#### path的方法

****

```js
const path = require('path');



// 1.获取路径信息
const filepath = 'User/qmj/abc.txt';

console.log(path.dirname(filepath))  // User/qmj
console.log(path.basename(filepath)) // abc.txt
console.log(path.extname(filepath)); // .txt

// 2.join路径拼接

const basepath1 = '/User/qmj';
const filename = 'aaa.txt';
const filepath1 = path.join(basepath1, filename) 

console.log(filepath1) // \User\qmj\aaa.txt

// 3.路径拼接

const filepath2 = path.resolve(basepath1, filename);
console.log(filepath2)  // D:\User\qmj\aaa.txt
```

### 2.文件系统 ——fs模块

node中文件系统的api很多，但是大多数api都提供了三种操作方式：

- 方式一：同步操作文件：代码会被阻塞，不会继续执行。
- 方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；
- 方式三：异步Promise操作文件：代码不会被阻塞，通过fs.promises调用方法操作，会返回一个Promise，可以通过then，catch进行处理。

#### fs的三种操作模式

```js
const fs = require('fs')

// 读取文件信息
const filepath = "./a.txt"

// 1.方式一：同步操作 阻塞
const info = fs.statSync(filepath)
console.log(info)

// 2.方式二：异步操作 不会阻塞
fs.stat(filepath, (err)=> {
  if(err) {
    console.log(err)
    return;
  }
  console.log(info)
})
// 3.方式三 promise的方式，不会回调地狱
fs.promises.stat(filepath).then( info => {
  console.log(info);
}).catch(err => {
  console.log(err)
})
```

#### 文件描述符

- 在POSIX系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。
- 每个打开的文件都分配额一个成为文件描述符的简单的数字标识符。
- 在系统层，所有文件系统操作都是用这些文件描述符来标识和跟踪每个特定的文件。
- Windows系统使用了一个虽然不同但概念上类似的机制来跟踪资源。

```js
const fs = require('fs')

fs.open("./a.txt",(err,fd) => {
  if(err) {
    console.log(err)
    return
  }

  // 可以通过描述符去获取文件的信息 异步
  fs.fstat(fd, (err, info) => {
    console.log(info)
  })
  console.log(fd)  // 先被执行
})
```

#### 文件的读写

- fs.writeFile(文件，内容，options, err回调)
  - options：flag可以有不同写入操作，追加，覆盖等等，a追加

```js
const fs = require('fs')

const content = '吃了吗？hahh'

fs.writeFile('./a.txt',content,{flag: "a"}, err => {
  if(err) console.log(err)
})
```

#### 文件夹的操作

```js
const fs = require('fs');
const path = require('path')

// 1.创建文件夹
const dirname = './qmj';
if(!fs.existsSync(dirname)) {
  fs.mkdir(dirname, err => {
    if(err) console.log(err)
  })
}

// 2.读取文件夹中的所有文件
const getFilename = (dirname) =>{
  fs.readdir(dirname,{withFileTypes: true}, (err,files)=>{
    for(let file of files) {
      if(file.isDirectory()) {
        const filepath = path.resolve(dirname,file.name)
        getFilename(filepath)
      }else {
        console.log(file)
      }
    }
  })
}
    
getFilename(dirname)
// Dirent { name: 'bb.txt', [Symbol(type)]: 1 }
// Dirent { name: 'qmj.txt', [Symbol(type)]: 1 }
// Dirent { name: 'aa.js', [Symbol(type)]: 1 }
// Dirent { name: 'cc.png', [Symbol(type)]: 1 }
```

### 3.events模块

####  events基础方法

- 创建发射器
- 注册监听
- 发射事件
- 取消监听

```js
const EventEmitter = require('events');

// 创建发射器
const emitter = new EventEmitter();

// 2.监听某一个事件
// on是addListener的别名、

const listener2 = (args) => {
  console.log('监听到click2事件',args);
}
emitter.on('click', listener2)
emitter.on('click', args => {
  console.log('监听click1事件', args)
})

// 3.发出一个事件 
setTimeout(() => {
  emitter.emit('click', 'qmj', 'link', 'kobe');
  emitter.off('click',listener2) // 取消监听
  emitter.emit('click', 'qmj', 'link', 'kobe');
}, 2000);


```

#### events获取信息

- 获取注册事件
- 获取注册函数个数
- 获取注册函数名称

```js
const EventEmitter = require('events');

// 创建发射器
const emitter = new EventEmitter();

// 2.监听某一个事件
// on是addListener的别名、

const listener2 = (args) => {
  console.log('监听到click2事件',args);
}
emitter.on('click', listener2)
emitter.on('tap', args => {
  console.log('监听click1事件', args)
})

// 获取注册事件
console.log(emitter.eventNames())
// 获取注册函数个数
console.log(emitter.listenerCount('click'))
// 获取注册函数名称
console.log(emitter.listeners('click'));
```

#### events不常用方法

- once 值监听一次
- prependListener优先执行
- removeAllListeners移除所有，可以传参数

## 四、发布自己的npm

### 1.npm的原理

- 查看缓存位置 npm config get cache

![npm原理](./nodeImgs/node_npm_01.png)

### 2.开发自己的脚手架模板

原因：

- 使用官方的是毫无配置的。
- 没有划分目录结构、config.js。
- 没有请求相关的第三方库。
- 没有element-ui，antd等ui库
- 也没有路由相关的配置

那么每一次创建项目的时候又要去下载这些常使用的第三方，所以我们可以定义一个模板进行复用。



#### 自定义终端命令

- 在终端输入qmj时报错。
- 第一：先要在index.js入口文件配好环境 *#!/user/bin/env node*
- 第二：在package.json里面 "bin": {  "qmj": "index.js" },
- 第三：终端运行 npm link就可以连接你的qmj命令
- 输入qmj会执行index文件。

#### 增加自己的options

- 可以在终端中使用，--help可以查看这些命令
- 可以用on监听哪个option被监听。

```js
#!/usr/bin/env node
const program = require('commander')
// 查看版本号
program.version(require('./package.json').version)
// 增加自己的options
program.option('-q --qmj', 'a qmj cli');
program.option('-d --dest <dest>', 'a destination folder, 例如： -d /src/components');
program.option('-f --framework <framework>', 'your framework');

program.on('--help', function() {
  console.log("")
  console.log("Other");
  console.log(" other options~")
})
program.parse(process.argv)
console.log(program.dest)
```

#### 定义创建项目的action

- 克隆项目
  - 用到一个叫download-git-repo的库，传入参数等
- 执行npm install
  - 需要注意判断不同的平台，在win上面执行的是npm.cmd
  -  await commandSpawn(command, ['install'], {cwd: `./${project}`})
- 运行npm run serve
  - await commandSpawn(command, ['run', 'serve'], {cwd: `./${project}`})
- 打开浏览器
  - 用到一个open的库

