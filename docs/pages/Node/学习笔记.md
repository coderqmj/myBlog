##  一、浏览器内核

> 谷歌之前用的是webkit，后来又使用Blink，属于为webkit的一个分支，谷歌开发，用于谷歌浏览器。

#### 什么是浏览器内核？

```
事实上，浏览器内核指的是浏览器的排版引擎：
	排版引擎也叫浏览器引擎，页面渲染引擎，样板引擎。
```

#### 渲染流程就是那张图了

在html里面可以执行JS是因为每个浏览器都有JS引擎

#### JS引擎

- webkit的JS引擎，苹果公司开发
  - 两部分：webCore(HTML解析)+JSCore
- V8谷歌开发，很强大。

#### V8如何运行JS

- 源码100W行c++代码
- 主要原理：
  - 黑色的是模块。
  - 分别是解析器、解释器、

```
1.Parse将JS代码转换成AST(abstract syntax tree)抽象语法树.
2.Ignition将语法树解释成字节码（类似汇编代码），字节码再进一步转成汇编，再转机器码，交给cup执行
```

![v8原理](./nodeImgs/node_v8_1.png)

#### 为什么V8高效

```
1.因为js是一门解释型语言，转成字节码交给cpu执行过程较为复杂，效率较低，需要字节码转汇编再转机器。
2、v8对js执行过程做了优化：
	1.会收集信息（博客上的图），如参数类型。
	2.将这些代码通过另外一个模块TurboFan将字节码直接转换成优化好的机器码，下一次再运行类似函数时就直接走TurboFan模块。
3.收集到了足够的类型信息，将字节码直接转换成优化好的机器码。直接进行执行。之后在运行代码走这个过程效率变得更高。

缺点/问题：
	1.比如一个sum(num1, num2)函数，第一次传入的是数字，那么下次再转换成机器码的时候传入的参数也会被按照数字来处理。
	例子：sum('AA','bbb'),就会让两个字符串进行拼接。
解决(博客的图)：
	转换成机器码之后再多一笔操作，
	Deoptimization（反向优化）：
		在某些特殊的情况下，反向优化成字节码，再优化成机器码执行。
```

## 二、邂逅NODE

#### 2.1常见的node全局对象

- process对象：process提供了Node进程中相关的信息：

  - node中的运行环境，参数信息等；
  - 可以将环境变量读取到process的env中。

- console

- 定时器函数

  - ```js
    setTimeout(() => {
      console.log('setTimeout')
    }, 1000);
    
    setInterval(() => {
      console.log('setInterval')
    }, 1000);
    
    setImmediate(() => {
      console.log('setImmediate')
    })
    
    process.nextTick(()=> {
      console.log('process.nextTick')
    })
    // nextTick -> setImmediate -> setTimeout -> setInterval...
    ```

  - 

#### 2.2特殊的全局对象

> 这些全局对象实际上是模块中的变量，只是每个模块都有，看起来像全局变量。但是在命令行交互中不可以使用，比如，__ dirname, __filename, exports, module, require().



## 一、JavaScript模块化

### 1.1什么是模块化？

- 模块开发开发最终目的是将程序划分成一个个小的结构。
- 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响其他结构。
- 这个结构可以将自己希望暴露的变量，函数，对象等导出给其结构使用。
- 也可以导入另外结构的变量函数，对象等。

### 1.2没有模块化带来的问题

- 变量 全局污染

### 1.3模块化的规范

> 模块化有AMD，CMD，CommonJS等是定义用什么样的归案去写代码，统一规范。每个模块化都有两个核心功能，模块本身导出暴露的属性，模块又可以导入自己需要的属性。

#### CommonJS和Node

- CommonJS是一个规范，而node是CommonJS在服务端一个具有代表的实现。
- webpack（模块化打包工具）打包工具具备对CommonJS的支持和转换。

所以，node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：

- 在Node中每一个js都是单独的模块；
- 这个模块中包括CommonJS规范的核心：exports，module.exports, require;
- 我们可以使用这些变量来方便的进行模块化开发。

#### exports 和 require

在单独的模块里面定义了变量可以用`exports`导出，可以用`require`导入；

```js
// a.js
const name = 'qmj';
exports.name = name;

// b.js
const obj = require('./a.js');
console.log(obj.name) // qmj
```

#### module.exports

- 既然可以用exports直接导出，为什么常用的是module.exports。
  - exports和module.exports的区别？
    - 在内部做的事情是 module.exports = exports;
    - 如果自己module.exports = {}那么就可以断开引用了
- 通过查询维基百科CommonJS规范的解析：
  - CommonJS中是没有module.exports的概念的；
  - 但是为了实现模块的导出，Node中使用的是Module（一个js文件就是一个module实例）的类，每一个模块都是Module的实例，就是module。
  - 所以在node中真正用于导出的其实根本不是exports，而是module.exports;
  - 因为module才是导出的真正实现者。

```
// a.js
const name = 'qmj';
module.exports = {
	name: name;
};

// b.js
const obj = require('./a.js');
console.log(obj.name) // qmj
```

## 三、常见内置模块

### 1.路径的模块——path

> 在不同操作系统中路径的形式有可能是不一样的，有的是// 有的是\ 那么一套代码就不可以在不同操作系统中使用了。那么调用path模块可以解决这个问题。

```js
const path = require('path');
const basePath = '/User/qmj';
const fileName = 'abc.txt';

const filepath = path.resolve(basePath, fileName)

```

#### path的方法

****

```js
const path = require('path');



// 1.获取路径信息
const filepath = 'User/qmj/abc.txt';

console.log(path.dirname(filepath))  // User/qmj
console.log(path.basename(filepath)) // abc.txt
console.log(path.extname(filepath)); // .txt

// 2.join路径拼接

const basepath1 = '/User/qmj';
const filename = 'aaa.txt';
const filepath1 = path.join(basepath1, filename) 

console.log(filepath1) // \User\qmj\aaa.txt

// 3.路径拼接

const filepath2 = path.resolve(basepath1, filename);
console.log(filepath2)  // D:\User\qmj\aaa.txt
```

### 2.文件系统 ——fs模块

node中文件系统的api很多，但是大多数api都提供了三种操作方式：

- 方式一：同步操作文件：代码会被阻塞，不会继续执行。
- 方式二：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；
- 方式三：异步Promise操作文件：代码不会被阻塞，通过fs.promises调用方法操作，会返回一个Promise，可以通过then，catch进行处理。

#### fs的三种操作模式

```js
const fs = require('fs')

// 读取文件信息
const filepath = "./a.txt"

// 1.方式一：同步操作 阻塞
const info = fs.statSync(filepath)
console.log(info)

// 2.方式二：异步操作 不会阻塞
fs.stat(filepath, (err)=> {
  if(err) {
    console.log(err)
    return;
  }
  console.log(info)
})
// 3.方式三 promise的方式，不会回调地狱
fs.promises.stat(filepath).then( info => {
  console.log(info);
}).catch(err => {
  console.log(err)
})
```

#### 文件描述符

- 在POSIX系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。
- 每个打开的文件都分配额一个成为文件描述符的简单的数字标识符。
- 在系统层，所有文件系统操作都是用这些文件描述符来标识和跟踪每个特定的文件。
- Windows系统使用了一个虽然不同但概念上类似的机制来跟踪资源。

```js
const fs = require('fs')

fs.open("./a.txt",(err,fd) => {
  if(err) {
    console.log(err)
    return
  }

  // 可以通过描述符去获取文件的信息 异步
  fs.fstat(fd, (err, info) => {
    console.log(info)
  })
  console.log(fd)  // 先被执行
})
```

#### 文件的读写

- fs.writeFile(文件，内容，options, err回调)
  - options：flag可以有不同写入操作，追加，覆盖等等，a追加

```js
const fs = require('fs')

const content = '吃了吗？hahh'

fs.writeFile('./a.txt',content,{flag: "a"}, err => {
  if(err) console.log(err)
})
```

#### 文件夹的操作

```js
const fs = require('fs');
const path = require('path')

// 1.创建文件夹
const dirname = './qmj';
if(!fs.existsSync(dirname)) {
  fs.mkdir(dirname, err => {
    if(err) console.log(err)
  })
}

// 2.读取文件夹中的所有文件
const getFilename = (dirname) =>{
  fs.readdir(dirname,{withFileTypes: true}, (err,files)=>{
    for(let file of files) {
      if(file.isDirectory()) {
        const filepath = path.resolve(dirname,file.name)
        getFilename(filepath)
      }else {
        console.log(file)
      }
    }
  })
}
    
getFilename(dirname)
// Dirent { name: 'bb.txt', [Symbol(type)]: 1 }
// Dirent { name: 'qmj.txt', [Symbol(type)]: 1 }
// Dirent { name: 'aa.js', [Symbol(type)]: 1 }
// Dirent { name: 'cc.png', [Symbol(type)]: 1 }
```

### 3.events模块

####  events基础方法

- 创建发射器
- 注册监听
- 发射事件
- 取消监听

```js
const EventEmitter = require('events');

// 创建发射器
const emitter = new EventEmitter();

// 2.监听某一个事件
// on是addListener的别名、

const listener2 = (args) => {
  console.log('监听到click2事件',args);
}
emitter.on('click', listener2)
emitter.on('click', args => {
  console.log('监听click1事件', args)
})

// 3.发出一个事件 
setTimeout(() => {
  emitter.emit('click', 'qmj', 'link', 'kobe');
  emitter.off('click',listener2) // 取消监听
  emitter.emit('click', 'qmj', 'link', 'kobe');
}, 2000);


```

#### events获取信息

- 获取注册事件
- 获取注册函数个数
- 获取注册函数名称

```js
const EventEmitter = require('events');

// 创建发射器
const emitter = new EventEmitter();

// 2.监听某一个事件
// on是addListener的别名、

const listener2 = (args) => {
  console.log('监听到click2事件',args);
}
emitter.on('click', listener2)
emitter.on('tap', args => {
  console.log('监听click1事件', args)
})

// 获取注册事件
console.log(emitter.eventNames())
// 获取注册函数个数
console.log(emitter.listenerCount('click'))
// 获取注册函数名称
console.log(emitter.listeners('click'));
```

#### events不常用方法

- once 值监听一次
- prependListener优先执行
- removeAllListeners移除所有，可以传参数

## 四、发布自己的npm

### 1.npm的原理

- 查看缓存位置 npm config get cache

![npm原理](./nodeImgs/node_npm_01.png)

### 2.开发自己的脚手架模板

原因：

- 使用官方的是毫无配置的。
- 没有划分目录结构、config.js。
- 没有请求相关的第三方库。
- 没有element-ui，antd等ui库
- 也没有路由相关的配置

那么每一次创建项目的时候又要去下载这些常使用的第三方，所以我们可以定义一个模板进行复用。



#### 自定义终端命令

- 在终端输入qmj时报错。
- 第一：先要在index.js入口文件配好环境 *#!/user/bin/env node*
- 第二：在package.json里面 "bin": {  "qmj": "index.js" },
- 第三：终端运行 npm link就可以连接你的qmj命令
- 输入qmj会执行index文件。

#### 增加自己的options

- 可以在终端中使用，--help可以查看这些命令
- 可以用on监听哪个option被监听。

```js
#!/usr/bin/env node
const program = require('commander')
// 查看版本号
program.version(require('./package.json').version)
// 增加自己的options
program.option('-q --qmj', 'a qmj cli');
program.option('-d --dest <dest>', 'a destination folder, 例如： -d /src/components');
program.option('-f --framework <framework>', 'your framework');

program.on('--help', function() {
  console.log("")
  console.log("Other");
  console.log(" other options~")
})
program.parse(process.argv)
console.log(program.dest)
```

#### 定义创建项目的action

- 克隆项目
  - 用到一个叫download-git-repo的库，传入参数等
- 执行npm install
  - 需要注意判断不同的平台，在win上面执行的是npm.cmd
  -  await commandSpawn(command, ['install'], {cwd: `./${project}`})
- 运行npm run serve
  - await commandSpawn(command, ['run', 'serve'], {cwd: `./${project}`})
- 打开浏览器
  - 用到一个open的库

## 五、文件处理

### 5.1Buffer

#### buffer和二进制

- 对于前端来说，很少和二进制打交道，但是对于服务端为了做更多的功能，我们必须直接去操作其二进制的数据；
- Node为了可以方便开发者完成更多功能，提供了一个类Buffer，属于去全局。
- Buffer中存储的是二进制数据，那么到底是如何存储呢？
  - -我们可以将Buffer看成是一个存储二进制的数组。
  - 这个数组中的每一项，可以保存8位二进制：00000000
- 为什么是8位？
  - 一位二进制存储数据量小。
  - 8位就是一个单元，这个单元称为一个字节。
  - 1byte=8bit，1kb=1024byte，1M=1024kb；

#### buffer和字符串

- 可以得出结论一个英文字符占一个字节，一个中文占三个字节

```js
const message1 = "Hello"; 
const message2 = "你好啊"; 
const buffer1 = new Buffer.from(message1)  // <Buffer 48 65 6c 6c 6f> 16进制
const buffer2 = new Buffer.from(message2)  // <Buffer e4 bd a0 e5 a5 bd e5 95 8a>
```

#### buffer操作图片

- writeFile可以直接复制图片
- sharp这个库可以操作图片

### 5.2Stream

> 流是从一个文件读取数据时，文件的二进制（字节）数据源源不断的被读取到我们程序中；这一连串的字节，即使我们程序中的流。它可读可写。

- 之前学过readFile和writeFile方式读写文件，那为什么还要流呢？
  - -直接读写文件的方式，无法控制一些细节的操作；
  - 比如什么位置开始读，读到什么位置，一次星都区多少个字节；
  - 读到某个位置后，暂停读取，某个时刻恢复读取等等；

## 六、HTTP

### 6.2 header属性

- content-type
  - application/json 表示是一个json类型
  - text/plain表示是一个文本类型
  - application/xml表示是xml类型
  - multipart/form-data表示是上传文件

- content-length：文件大小和长度
- keep-alive：
  - http是基于tcp协议的，但是通常在进行换一次请求和相应会立刻中断。
  - http1.0中，想要保持持续链接：
    - 请求头加 connection：keep-alive
    - 服务端在响应头加connection: keep-alive
    - 当客户端再次请求时，就会使用同一个连接，直接一方中断连接；
  - 在http1.1中，默认开启connection:keep-alive的
    - 不同web服务器会有不同的保持keep-alive的时间
    - node中就是默认5s
- accept-encoding：告诉服务器，客户端支持的文件压缩格式，比如js文件客户已使用gzip编码
- accept：告知服务器，客户端可以接受文件的格式类型。
- user-agent： 客户端的相关信息。

### 6.3响应

#### 响应结果

res.end('hello') === res.write('hello') + res.end()

#### 响应状态码

两种设置状态码的方式：

- res.statusCode = 400
- res.writeHead(503, {})

#### 设置响应header

- res.setHeader('Content-Type', "text/plain;charest=utf-8")
- res.writeHead('200', { 'Content-Type': "application/json;charest=utf-8" })

### 6.4HTTP发送请求

#### 方式一：get请求

```js
//1.get请求
http.get('http://localhost:1732', (res) => {
  res.on('data', (data) => {
    console.log(data.toString())
  })
  res.on('end', () => {
    console.log('结束')
  })
})
```

#### 方式二：post请求

- 它要比get多做一步end的操作，get不用是因为内部已经实现了

```js
const req = http.request({
  method: 'POST',
  hostname: 'localhost',
  port: '1732',
}, (res) => {
  res.on('data', (data) => {
    console.log(data.toString())
  })
  res.on('end', () => {
    console.log('结束')
  })
})
req.end()
```

### 6.5文件上传

#### 文件上传——错误示例

- 原因是这样得到的数据时包含 图片信息+其他信息
- 其他信息就是图片名字，content-type等等

![原因](./nodeImgs/HTTPUpload_1.png)

```js
const http= require('http');
const fs = require('fs');

// 错误写法
const server = http.createServer((req ,res) => {
  if(req.url === '/upload') {
    if(req.method === 'POST') {
      const flieWriter = fs.createWriteStream('./foo.png',{flags: 'a+'});
      req.on('data', (data) => {
        console.log(data);
        // 包含着图片+其他信息，所以不能正常显示。
        flieWriter.write(data);
      });

      req.on('end', ()=> {
        console.log('文件上传成功！！');
        res.end('文件上传成功~')
      })
    }
  }
})

// 监听端口
server.listen(1732, '0.0.0.0', () => {
  console.log('服务器启动在1732端口')
});
```

#### 文件上传——正确的示例

- 需要对获取到的data做处理，只获取data里面图片的数据就行
- 需要做三件事情：
  - 去掉image/png前面的
  - 去掉\r\n\r\n
  - 去掉后面的boundary。-----------2157

```js
const http= require('http');
const fs = require('fs');
const qs = require('querystring');

// 错误写法
const server = http.createServer((req ,res) => {
  if(req.url === '/upload') {
    if(req.method === 'POST') {
      req.setEncoding('binary');
      let body = '';
      const totalBoundary = req.headers['content-type'].split(';')[1];
      const boundary = totalBoundary.split('=')[1];
      req.on('data', (data) => {
        body += data;
      });

      req.on('end', ()=> {
        console.log(body)
        // 处理body
        // 1.处理img前面的问题
        const payload = qs.parse(body, "\r\n", ":")
        const type = payload["Content-Type"]; // 拿到图片类型
        // 拿到图片的位置
        const typeIndex = body.indexOf(type);
        const typeLength = type.length;
        let imageData = body.substring(typeIndex+typeLength )

        // 3.去掉空格
        imageData = imageData.replace(/^\s\s*/, '');
        
        // 4.将最后的boundary去掉
        imageData = imageData.substring(0, imageData.indexOf(`--${boundary}--`)) 
        fs.writeFile('./foo.png', imageData, {encoding: 'binary'}, (err) => {
          console.log('文件上传成功')
        })
        console.log('文件上传成功！！');
        res.end('文件上传成功~')
      })
    }
  }
})

// 监听端口
server.listen(1733, '0.0.0.0', () => {
  console.log('服务器启动在1732端口')
});
```

## 七、框架

### 7.1.Express

#### 7.1.1express的使用

- 安装 npm i -g express-generator
- 创建 express express-demo
- 安装依赖 npm i 
- 启动项目 node bin/www

#### 7.1.2解剖express

**基本情况**

- express实际上是一个函数，创建application的函数
- 三部曲也是导入，创建实例，启动监听
- 根据不同请求调用不同方法

```js
// 1.导入
const express = require('express');

// 2.创建app
const app =  express();

// 4.做出处理
app.get('/', (req, res, next) => {
  res.end('Hello express!')
})

app.post('/login', (req, res, next) => {
  res.end('Please login~')
})

// 3.启动监听
app.listen(8000, () => {
  console.log('服务器启动成功~')
})
```

#### 7.1.2认识中间件

- express是一个路由和中间件的Web框架，它本身的功能非常少
  - Express应用程序本质上是一些列中间件函数的调用



- 什么是中间件？
  - 中间件本质是传递给express的一个回调函数
  - 这个回调函数接收三个参数：
    - 请求对象（request）；
    - 响应对象（response对象）
    - next函数（在express中定义的用于执行下一个中间件的函数）



- 中间件可以执行哪些任务呢？

  - 执行让任何代码
  - 更改请求（request）和响应（response）对象
  - 结束请求-响应周期（返回数据）
  - 调用栈中的下一个中间件




- 如何将一个中间件应用到我们的应用程序中？
  - express主要有两种方式：app/router.use和app/router.methods
  - methods值的是常用的请求方式，比如app.get 或者 app.post等；



- use的用法，因为methods的方式本质是use的特殊情况
  - 普通中间件不管是get和post都可以请求成功，但是又多个use时，只会作用在第一个中间件。
  - 如果不想只调用第一个，那就next

**普通中间件**

- 普通中间件不管是get和post都可以请求成功，但是又多个use时，只会作用在第一个中间件。
- 如果不想只调用第一个，那就next

```js
const express = require('express');

const app = express();

// 编写普通中间件

// 1.use注册中间件
app.use((req, res, next) => {
  console.log("注册了第01个普通中间件~");
  next()
})

app.use((req, res, next) => {
  console.log("注册了第02个普通中间件~");
  next()
})

app.use((req, res, next) => {
  console.log("注册了第03个普通中间件~");
  res.end("hello qmj11111")
})

app.listen(8000, () => {
  console.log("普通中间件服务器启动成功~");
})
```

**路径中间件**

- 路径匹配上了，但是没有指定，所以不管get，post都可以请求到
- 同样也是next到哪里就执行到哪里

```js
const express = require('express');

const app =  express();

// 路径匹配中间件
app.use('/home', (req, res, next) => {
  res.end('Welcome to Home~')
})

app.listen(8000, () => {
  console.log('服务器启动成功~')
})
```



**方法和路径中间件**

```js
const express = require('express');

const app =  express();

app.get('/home', (req, res, next) => {
  res.end('Hello express!')
})

app.post('/login', (req, res, next) => {
  res.end('Please login~')
})

app.listen(8000, () => {
  console.log('服务器启动成功~')
})
```



**注册连续中间件**

```js
// 1.导入
const express = require('express');

// 2.创建app
const app =  express();

app.use((req, res, next) => {
  console.log('中间件');
  next();
})

// 4.做出处理
app.get('/home', (req, res, next) => {
  console.log("中间件01")
  next();
}, (req, res, next) => {
  console.log("中间件02")
}, (req, res, next) => {
  console.log("中间件03")
}, (req, res, next) => {
  console.log("中间件04")
  res.end('home page')
})

app.post('/login', (req, res, next) => {
  res.end('Please login~')
})

// 3.启动监听
app.listen(8000, () => {
  console.log('服务器启动成功~')
})
```





- 注意的地方：

  - 如果没在一个中间件中调用end，那么必须调用next，否则一直会停留在该中间件中。
  - app.get 和 app.post也是一个中间件 
  - 不调用next永远匹配都是第一个中间件
  - 如果哪一个没有next，那么就在就在那个调用完就不会下一个了

  

#### 7.1.3中间件的应用

**json解析**

- 普通解析的话不同路径就需要做相同业务逻辑。
- 使用公共中间件就可以抽离出相同业务，就比如解析Json
- 或者也可以使用内部实现好的`app.use(express.json())`

```js
const express = require('express');

const app =  express();

// 手动判断，内部有已经实现好的
// app.use((req, res, next) => {
//   console.log(req.headers['content-type'])
//   if(req.headers['content-type'] === 'application/json') {
//     req.on('data', (data) =>{
//       const info = JSON.parse(data.toString());
//       req.body = info;
//     })

//     req.on('end', () => {
//       res.end('haha');
//       next();
//     })
//   } else {
//     next();
//   }
// })

app.use(express.json())

app.post('/login', (req, res, next) => {
  console.log(req.body);
  res.end('hhahah')
  req.on('end', () => {
    res.end('qmj, Welcome Back~');
  })
})
app.post('/products', (req, res, next) => {
  console.log(req.body);
  res.end('hhahah')
  req.on('end', () => {
    res.end('qmj, Welcome Back~');
  })
})

app.listen(8000, () => {
  console.log('服务器启动成功~')
})
```

**表单提交——form-data**

- 安装第三方库——mulfer
- 非文件类型使用any

```js
const express = require('express');
const multer = require('multer');

const app = express();

const upload = multer();

app.use(upload.any());  // 非文件类型用any



app.post('/login', (req, res, next) => {
  console.log(req.body)
  res.end("登陆成功")
})

app.listen(8000, () => {
  console.log("form-data解析服务器启动成功~")
})
```



**文件上传——form-data**

- 将key设为file类型
- 使用multer里面的diskStorage。
- destination和filename都是要一个回调函数，分别存下路径和文件名信息

```js
const path = require('path');

const express = require('express');
const multer = require('multer');

const app = express();

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, './upload/');
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  }
})

const upload = multer({
  // dest: './upload/'
  storage
});

app.use(upload.any());  // 非文件类型用any

app.post('/upload', upload.single('file') , (req, res, next) => {
  console.log(req.body)
  res.end("文件上传成功")
})

app.listen(8000, () => {
  console.log("form-data解析服务器启动成功~")
})
```



**解析参数**

```js
// 1.导入
const express = require('express');

// 2.创建app
const app =  express();

// 4.做出处理
app.get('/products/:id/:name', (req, res, next) => {
  console.log(req.params);
  res.end('获取商品数据详情~')
})

app.get('/login', (req, res, next) => {
  console.log(req.query)
  res.end('登陆成功')
})
// 3.启动监听
app.listen(8000, () => {
  console.log('服务器启动成功~')
})
```

